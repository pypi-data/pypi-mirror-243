from _typeshed import Incomplete
from amsdal_data.connections.errors import AmsdalConnectionError as AmsdalConnectionError
from amsdal_data.table_schemas.constants import PRIMARY_PARTITION_KEY as PRIMARY_PARTITION_KEY
from amsdal_utils.models.data_models.address import Address as Address
from amsdal_utils.query.data_models.filter import Filter as Filter
from amsdal_utils.query.data_models.order_by import OrderBy as OrderBy
from amsdal_utils.query.data_models.paginator import CursorPaginator, NumberPaginator
from amsdal_utils.query.data_models.query_specifier import QuerySpecifier as QuerySpecifier
from amsdal_utils.query.enums import Lookup
from amsdal_utils.query.utils import Q
from collections.abc import Callable as Callable
from pydantic import BaseModel
from typing import Any, ClassVar

SUPPORTED_NESTED_FIELDS: Incomplete
ADDRESS_FIELD: str

class NoValue: ...

class SqlOperatorTemplate(BaseModel):
    build_statement: ClassVar[Callable[[Any, str, Any], str]]
    build_value: ClassVar[Callable[[Any, Any], Any]]
    template: str | Callable[[Any], str]
    value_template: str | None
    value_modifier: Callable[[Any], Any] | None
    def build_statement(self, field_name: str, value: Any) -> str: ...
    def build_value(self, value: Any) -> Any: ...

sql_operator_map: dict[Lookup, SqlOperatorTemplate]

class SqlStateConnectionMixin:
    def _build_count_statement(self, address: Address, conditions: Q | None = ...) -> tuple[str, list[Any]]: ...
    def _build_select_statement(self, address: Address, query_specifier: QuerySpecifier | None = ..., conditions: Q | None = ..., pagination: NumberPaginator | CursorPaginator | None = ..., order_by: list[OrderBy] | None = ...) -> tuple[str, list[Any]]: ...
    def _get_conditions_statement(self, conditions: Q, *, is_grouped: bool = ...) -> tuple[str, list[Any]]: ...
    def _get_filter_statement(self, filter_item: Filter) -> tuple[str, Any]: ...
    def _address_filter_statement(self, nested_fields: str, sql_operator_template: SqlOperatorTemplate, value: Any) -> tuple[str, Any]: ...
    def _nested_filter_statement(self, field_name: str, nested_fields: str, sql_operator_template: SqlOperatorTemplate, value: Any) -> tuple[str, Any]: ...
    @classmethod
    def _to_sql_value(cls, value: Any) -> Any: ...
    def _build_insert_statement(self, address: Address, data: dict[str, Any]) -> tuple[str, tuple[Any, ...]]: ...
    def _build_update_statement(self, address: Address, data: dict[str, Any]) -> tuple[str, tuple[Any, ...]]: ...
    def _build_delete_statement(self, address: Address) -> tuple[str, tuple[Any, ...]]: ...
    def _get_table_name(self, address: Address) -> str: ...
