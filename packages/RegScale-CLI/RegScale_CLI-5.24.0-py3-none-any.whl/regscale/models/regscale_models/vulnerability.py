"""Standard Imports"""
from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime
from typing import List, Optional
from urllib.parse import urljoin

from pydantic import BaseModel, Field
from requests import Response

from regscale.core.app.api import Api
from regscale.core.app.application import Application
from regscale.core.app.logz import create_logger
from regscale.core.app.utils.app_utils import convert_datetime_to_regscale_string
from regscale.models.regscale_models.regscale_model import RegScaleModel


class Vulnerability(RegScaleModel):
    """Vulnerability Model"""

    id: Optional[int]
    uuid: Optional[str]
    scanId: Optional[int]
    parentId: Optional[int]
    parentModule: Optional[str]
    lastSeen: Optional[str]
    firstSeen: Optional[str]
    daysOpen: Optional[int]
    dns: Optional[str]
    ipAddress: Optional[str]
    mitigated: Optional[bool]
    uuid: Optional[str]
    scanId: Optional[int]
    parentId: Optional[int]
    parentModule: Optional[str]
    lastSeen: Optional[str]
    firstSeen: Optional[str]
    daysOpen: Optional[int]
    dns: Optional[str]
    ipAddress: Optional[str]
    mitigated: Optional[bool]
    operatingSystem: Optional[str]
    port: Optional[str]
    port: Optional[str]
    protocol: Optional[str]
    severity: Optional[str]
    severity: Optional[str]
    plugInName: Optional[str]
    plugInId: Optional[int]
    plugInId: Optional[int]
    cve: Optional[str]
    vprScore: Optional[int]
    exploitAvailable: Optional[bool]
    title: Optional[str]
    vprScore: Optional[int]
    exploitAvailable: Optional[bool]
    cvsSv3BaseScore: Optional[int]
    title: Optional[str]
    description: Optional[str]
    plugInText: Optional[str]
    createdById: Optional[str]
    lastUpdatedById: Optional[str]
    tenantsId: Optional[int] = 0
    dateCreated: Optional[str] = convert_datetime_to_regscale_string(datetime.now())
    dateLastUpdated: Optional[str] = convert_datetime_to_regscale_string(datetime.now())

    @classmethod
    def logger(cls):
        """Logger for Vulnerability Model"""
        logger = create_logger()
        return logger

    @staticmethod
    def find_vulns_by_scan(app: Application, scan_id: int) -> List["Vulnerability"]:
        """
        Find Vulnerabilities by Scan ID

        :param Application app: Application instance
        :param int scan_id: Scan ID
        :return: List of Vulnerabilities
        :rtype: List[Vulnerability]
        """
        api = Api(app)
        api_url = urljoin(
            app.config.get("domain"), f"/api/vulnerability/getAllByParent/{scan_id}"
        )
        response = api.get(url=api_url, params={"scanId": scan_id})
        if response.ok:
            return [Vulnerability(**v) for v in response.json()]
        else:
            response.raise_for_status()

    @staticmethod
    def determine_cvss3_severity_text(cvs_sv3_base_score: float) -> str:
        """
        Determine CVSS3 Severity Text from CVSS3 Base Score

        :param float cvs_sv3_base_score: CVSS3 Base Score
        :return: CVSS3 Severity Text
        :rtype: str
        """
        results = "low"
        if 4.0 <= cvs_sv3_base_score <= 6.9:
            results = "medium"
        elif 7.0 <= cvs_sv3_base_score <= 8.9:
            results = "high"
        elif cvs_sv3_base_score > 8.9:
            results = "critical"
        return results

    @staticmethod
    def post_vulnerability(vulnerability: "Vulnerability") -> dict:
        """
        Post a vulnerability to the API

        :param "Vulnerability" vulnerability: The vulnerability to be posted
        :return: The response from the API as a dictionary
        :rtype: dict
        """
        app = Application()
        api = Api(app)
        api_url = urljoin(app.config.get("domain"), "/api/vulnerability")
        payload = vulnerability.dict()
        response = api.post(url=api_url, json=payload)
        return response.json() if response.ok else response.raise_for_status()

    @staticmethod
    def post_vulnerabilities(
        app: Application, vulnerabilities: List["Vulnerability"]
    ) -> None:
        """
        Insert new vulnerabilities into RegScale

        :param Application app: Application object
        :param List["Vulnerability"] vulnerabilities: List of Vulnerability objects
        :return: None
        """
        logger = create_logger()

        def batch_post(url: str, dat: list[dict]) -> Response:
            """Simple wrapper over a post command

            :param str url: URL to post to
            :param list[dict] dat: A list of JSON data to post
            :return: Response object
            :rtype: Response
            """
            res = api.post(url=url, json=dat)
            return res

        api = Api(app)
        logger.info("Posting %i new vulnerabilities in RegScale.", len(vulnerabilities))
        batch_post(
            url=urljoin(app.config.get("domain"), "/api/vulnerability/batchcreate"),
            dat=[vuln.dict() for vuln in vulnerabilities],
        )

    def __eq__(self, other) -> bool:
        """
        Determine equality of two Vulnerability objects

        :param other: Other Vulnerability object
        :return: True if equal, False if not
        :rtype: bool
        """
        if not isinstance(other, Vulnerability):
            # don't attempt to compare against unrelated types
            return NotImplemented

        return self.uuid == other.uuid

    @staticmethod
    def process_vulns(app: Application, new_vulns: List["Vulnerability"]) -> None:
        """
        Process Vulnerabilities

        :param Application app: Application Instance
        :param List["Vulnerability"] new_vulns: A list of new vulnerabilties
        :return: None
        """

        # Filter Vulns
        Vulnerability.post_vulnerabilities(app=app, vulnerabilities=new_vulns)
