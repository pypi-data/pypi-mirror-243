# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_path.ipynb.

# %% auto 0
__all__ = ['prep_path', 'fmatpaths', 'ExperimentPath', 'toadatafile', 'tobarcodesfile', 'tofeaturesfile', 'tomatrixfile',
           'load_barcodes', 'load_features', 'load_matrix', 'does_adata_exist', 'read_adata', 'make_adata',
           'load_adata', 'fmat2adata', 'FilterMatrixDirectory', 'AdataFile', 'BarcodesFile', 'FeaturesFile',
           'MatrixFile']

# %% ../nbs/01_path.ipynb 6
import os, re, itertools
from pathlib import Path

# %% ../nbs/01_path.ipynb 8
#| export


# %% ../nbs/01_path.ipynb 10
try:
    import numpy as np, pandas as pd, scanpy as sc, scprep
    from tqdm.auto import tqdm
except ImportError:
    print("Some dependencies are missing!")

# %% ../nbs/01_path.ipynb 12
from atyp import CallQ, PttnDict, AnnData, DataFrame, DataFrameQ, SPMatrix

from chck import notnone, isad, isnone
from chck.biol import isfilteredmatrixdir, isadatafile, isbarcodesfile, isfeaturesfile, ismatrixfile
from nchr import DASH
from nlit import (
    TIMEPOINT, CONDITION, REPLICATE, SAMPLE_IDX,
    NAME, ABRV, DESC, PTTN_DICT, PREP_PATH, ANTI_PTTN, EXCLUDE,
    FilteredMatrixFile, BARCODES, ENSEMBL_ID, GENE_SYMBOL, FEATURE_TYPE, 
    FILTERED_MATRIX, FEATURES, MATRIX, ADATA, DELATTRS
)

from psrc import pathpttns, dirdirs, fullpath, USER_DATA
from xath import Xath, NamedFile

from adic import adic
from pttn import getpttn, attrpttn
from putl import uniattrs, setdefaults, dictvals2tup, take, deconstruct

# %% ../nbs/01_path.ipynb 14
from .pttn import PTTN_DICT as PTTN_DEFS

# %% ../nbs/01_path.ipynb 18
def prep_path(path: Path) -> Path: 
    '''Split the path by `-` and return the last element'''
    return path.split(DASH)[-1]

def fmatpaths(
    data_dir: Path, pttn_dict: PttnDict = PTTN_DEFS, prep_path: CallQ = prep_path,
    anti_pttn: re.Pattern = None, exclude: set = {FILTERED_MATRIX, }, **kwargs
) -> list[Path]:
    '''Get filtered matrix paths'''
    paths, attrs = list(), (PTTN_DICT, PREP_PATH, ANTI_PTTN, EXCLUDE, )
    kwargs = setdefaults(kwargs, *attrs, **locals())
    for dirpath, _, _ in os.walk(fullpath(data_dir)):
        if not isfilteredmatrixdir(dirpath, checkname=True, checkfiles=False): continue
        found = pathpttns(dirpath, data_dir, **kwargs)
        paths.append(found)

    paths = sorted(paths, key=lambda p: dictvals2tup(p, pttn_dict.keys()))    
    paths = [dict(sample_idx=i, **path) for i, path in enumerate(paths)]
    return paths

# %% ../nbs/01_path.ipynb 20
class ExperimentPath(Xath): 
    def __init__(
        self, path: Path, 
        pttn_dict: PttnDict = PTTN_DEFS, 
        prep_path: CallQ = prep_path,
        anti_pttn: re.compile = None,
        *args, **kwargs
    ):
        kwargs = setdefaults(kwargs, NAME, ABRV, DESC, name=None, abrv=None, desc=None)        
        super().__init__(path, *args, **kwargs)

        self.pttn_dict = pttn_dict
        self.prep_path = prep_path
        self.anti_pttn = anti_pttn
        
        self.paths = (paths := self.getfmats())
        self.pathdict = adic(dict(zip(range(len(paths)), paths)))

    def astuples(self) -> list[tuple]:
        vals = list(map(lambda p: take(p, self.pttn_dict), self.paths))
        return list(map(dictvals2tup, vals))
    
    def getoptions(self) -> dict:
        return {k: uniattrs(k, *self.paths) for k in self.pttn_dict.keys()}
    
    def alloptions(self) -> dict:
        return list(itertools.product(*self.getoptions().values()))

    def getfmats(self) -> list[Path]:
        return fmatpaths(
            self, pttn_dict = self.pttn_dict, prep_path = self.prep_path, 
            anti_pttn = self.anti_pttn, exclude = {FILTERED_MATRIX, },
        )
    
    def __getattr__(self, item: str):
        attrs = dict()
        for name, pttn in self.pttn_dict.items():
            val = getpttn(item, pttn)            
            if notnone(val): 
                attrs[name] = val
                continue

            val = getpttn(item, attrpttn(name, *self.paths, ignorecase=True, use_digits=False))
            if notnone(val): 
                attrs[name] = val
                continue
        
        res = []
        for path in self.paths:
            valid = True
            for k, v in attrs.items():
                matched = re.search(str(v), str(path[k]), re.IGNORECASE)
                matched = notnone(matched)
                if k == TIMEPOINT and matched: break
                if k == CONDITION and matched: continue
                if k == REPLICATE and matched: continue
                if not matched:
                    valid = False
                    break

            if valid: res.append(path)
        return res
        
    def to_df(self) -> DataFrame:
        data = list(map(lambda p: take(p, self.pttn_dict), self.paths))
        return pd.DataFrame(self.paths).set_index(SAMPLE_IDX)

# %% ../nbs/01_path.ipynb 25
def toadatafile(path: Path) -> Path:
    if not isadatafile(path): return Path(path) / FilteredMatrixFile.ADATA
    return Path(path)

def tobarcodesfile(path: Path) -> bool:
    if not isbarcodesfile(path): return Path(path) / FilteredMatrixFile.BARCODES
    return Path(path)

def tofeaturesfile(path: Path) -> bool:
    if not isfeaturesfile(path): return Path(path) / FilteredMatrixFile.FEATURES
    return Path(path)

def tomatrixfile(path: Path) -> bool:
    if not ismatrixfile(path): return Path(path) / FilteredMatrixFile.MATRIX
    return Path(path).name == FilteredMatrixFile.FEATURES

# %% ../nbs/01_path.ipynb 27
def load_barcodes(path: Path) -> DataFrameQ:
    if not isbarcodesfile(path): path = tobarcodesfile(path)
    barcodes = pd.read_csv(path, sep='\t', header=None)
    barcodes.columns = [BARCODES]
    barcodes.index = pd.Series(barcodes.barcodes.copy().values)
    return barcodes

def load_features(path: Path) -> DataFrame:
    if not isfeaturesfile(path): path = tofeaturesfile(path)
    features = pd.read_csv(path, sep='\t', header=None)
    features.columns = [ENSEMBL_ID, GENE_SYMBOL, FEATURE_TYPE]
    features.index = pd.Series(features.ensembl_id.copy().values)
    return features

def load_matrix(path: Path) -> SPMatrix:
    if not ismatrixfile(path): path = tomatrixfile(path)
    matrix = scprep.io.load_mtx(fullpath, sparse=True).T
    return matrix

# %% ../nbs/01_path.ipynb 29
def does_adata_exist(path: Path) -> bool:
    if isadatafile(path := Path(path)) and path.is_file(): return True
    if toadatafile(path).is_file(): return True
    return False

def read_adata(path: Path) -> AnnData:
    if isadatafile(path := Path(path)) and path.is_file(): return sc.read_h5ad(path)
    if toadatafile(path).is_file(): return sc.read_h5ad(toadatafile(path))
    return None

def make_adata(barcodes: DataFrame, features: DataFrame, matrix: SPMatrix, delattrs: bool = True) -> AnnData:
    data = pd.DataFrame.sparse.from_spmatrix(matrix, columns=features.index, index = barcodes.index)
    adata = sc.AnnData(X=data.values, obs=barcodes, var=features)   
    if delattrs: del matrix, barcodes, features
    return adata

def load_adata(
    path: Path, 
    barcodes: DataFrameQ = None, 
    features: DataFrameQ = None, 
    matrix: DataFrameQ = None, 
    save: bool = False, delattrs: bool = True
) -> AnnData:
    if isad(adata := read_adata(path)): return adata
    if isnone(matrix):   matrix   = load_matrix(path)
    if isnone(barcodes): barcodes = load_barcodes(path)
    if isnone(features): features = load_features(path)
    adata = make_adata(barcodes, features, matrix, delattrs)
    if save: adata.write(path)
    return adata

def fmat2adata(path: Path, save: bool = False, **kwargs) -> AnnData:
    if does_adata_exist(path := Path(path)): return read_adata(path)

    steps = (FEATURES, BARCODES, MATRIX, ADATA)
    features, barcodes, matrix, adata, delattrs = deconstruct(kwargs, *steps, DELATTRS)
    steps = tqdm(steps, desc=path.name, leave=True)
    for step in steps:
        steps.set_postfix(stage=step)
        match step:
            case 'features':
                if isnone(features): features = load_features(path)
            case 'barcodes':
                if isnone(barcodes): barcodes = load_barcodes(path)
            case 'matrix':
                if isnone(matrix):   matrix   = load_matrix(path)
            case 'adata':
                adata = load_adata(barcodes, features, matrix, save, delattrs)
            case _: ...
    return adata

# %% ../nbs/01_path.ipynb 31
class FilterMatrixDirectory(Xath):
    def __init__(self, path: Path, *args, **kwargs):
        super().__init__(path, *args, **kwargs)
        self.prep()

    @property
    def adata(self) -> Path: return toadatafile(self)
    @property
    def matrix(self) -> Path: return tomatrixfile(self)
    @property
    def barcodes(self) -> Path: return tobarcodesfile(self)
    @property
    def features(self) -> Path: return tofeaturesfile(self)
    @property
    def is_valid(self) -> bool:
        return all(list(map(lambda p: p.is_file(), (self.matrix, self.barcodes, self.features))))

    def prep(self) -> AnnData: return fmat2adata(self, save=True)
    def load(self) -> AnnData: return read_adata(self.adata)

# %% ../nbs/01_path.ipynb 33
class AdataFile(NamedFile):    
    expected = [FilteredMatrixFile.ADATA.value]
    def __str__(self): return str(self.leaf)
    def __init__(self, path: Path = None, *args, **kwargs):
        kwargs.update(
            leaf=FilteredMatrixFile.ADATA.value,
            name='adata', abrv='adata', desc='AnnData object'
        )
        super().__init__(path, *args, **kwargs)
        
    def load(self): return load_adata(self.full)
    def make(
        self, barcodes: DataFrame, features: DataFrame, matrix: SPMatrix, 
        save: bool = False, delattrs: bool = True, __cache: bool = False):
        if __cache and hasattr(self, '_data'): return self._data
        adata = load_adata(self.full, barcodes, features, matrix, save, delattrs)
        if __cache: self._data = adata
        return adata
    
class BarcodesFile(NamedFile):    
    expected = [FilteredMatrixFile.BARCODES.value]
    def __str__(self): return str(self.leaf)
    def __init__(self, path: Path = None, *args, **kwargs):
        kwargs.update(
            leaf=FilteredMatrixFile.BARCODES.value, 
            name='barcodes', abrv='bc', desc='cell barcodes'
        )
        super().__init__(path, *args, **kwargs)
        
    def load(self, __cache: bool = False): 
        if __cache and hasattr(self, '_data'): return self._data
        barcodes = load_barcodes(self.full)
        if __cache: self._data = barcodes
        return barcodes
        
class FeaturesFile(NamedFile):    
    expected = [FilteredMatrixFile.FEATURES.value]
    def __str__(self): return str(self.leaf)
    def __init__(self, path: Path = None, *args, **kwargs):
        kwargs.update(
            leaf=FilteredMatrixFile.FEATURES.value,
            name='features', abrv='feat', desc='cell features'
        )
        super().__init__(path, *args, **kwargs)
        
    def load(self, __cache: bool = False):
        if __cache and hasattr(self, '_data'): return self._data
        features = load_features(self.full)
        if __cache: self._data = features
        return features
        
class MatrixFile(NamedFile):
    expected = [FilteredMatrixFile.MATRIX.value]
    def __str__(self): return str(self.leaf)
    def __init__(self, path: Path = None, *args, **kwargs):
        kwargs.update(
            leaf=FilteredMatrixFile.MATRIX.value,
            name='matrix', abrv='mtx', desc='expression matrix'
        )
        super().__init__(path, *args, **kwargs)
        
    def load(self, __cache: bool = False): 
        if __cache and hasattr(self, '_data'): return self._data
        matrix = load_matrix(self.full)
        if __cache: self._data = matrix
        return matrix
