import pyperclip as pc

def array1():
    print('''Пусть (x1,y1);...;(x37,y37) – реализация случайной выборки (X1,Y1);...;(X37,Y37) из двумерного нормального распределения N(μx;μy;σ2x;σ2y;ρ). Используя векторы x =(x1;...;x37) и y =(y1;...;y37), постройте асимптотический
0,77-доверительный интервал (θˆ1;θˆ2) для коэффициента корреляции ρ. В ответе укажите: 
1) выборочный коэффициент корреляции ρˆ;
2) верхнюю границу θˆ2 построенного доверительного интервала для ρ.

Исходные данные:
x = (-1,598; 1,067; 0,789; 0,546; -2,166; -2,004; 0,489; 0,113; -0,902; -0,776; -0,164; -0,541; 0,71; 0,082; -0,737; 0,655; 0,656; 0,498; -0,527; -0,185; 1,383; -0,283; -2,518; 0,688; 1,379; -0,254; 0,886; 0,221; -0,905; 1,209; 0,128; -0,949; 1,046; 1,272; -1,226; -0,964; -0,72),
y = (-2,102; 1,429; 1,516; 0,266; -1,612; -1,665; 1,203; 0,413; -0,96; -0,431; -0,575; -0,045; 0,654; 0,773; -0,584; 0,857; 0,668; 0,751; -0,605; -0,594; 1,547; -0,045; -2,164; 1,106; 1,206; 0,388; 0,577; -0,027; -1,309; 1,045; 0,85; -0,916; 1,362; 0,694; -1,108; -0,845; -0,963).''')
    
    s = '''
X = np.array((-1.598, 1.067, 0.789, 0.546, -2.166, -2.004, 0.489, 0.113, -0.902, -0.776, -0.164, -0.541, 0.71, 0.082, -0.737, 0.655, 0.656, 0.498, -0.527, -0.185, 1.383, -0.283, -2.518, 0.688, 1.379, -0.254, 0.886, 0.221, -0.905, 1.209, 0.128, -0.949, 1.046, 1.272, -1.226, -0.964, -0.72))
Y = np.array((-2.102, 1.429, 1.516, 0.266, -1.612, -1.665, 1.203, 0.413, -0.96, -0.431, -0.575, -0.045, 0.654, 0.773, -0.584, 0.857, 0.668, 0.751, -0.605, -0.594, 1.547, -0.045, -2.164, 1.106, 1.206, 0.388, 0.577, -0.027, -1.309, 1.045, 0.85, -0.916, 1.362, 0.694, -1.108, -0.845, -0.963))
XY = np.array([X, Y])
gamma = 0.77

ro = np.corrcoef(X, Y)[0, 1]
alpha = 1 - gamma
z = norm(0, 1).isf(alpha/2)
print(ro)

u2 = math.atanh(ro) + z/(len(X)-3)**(1/2)
print(math.tanh(u2))
    '''
    return pc.copy(s)


def array2():
    print('''Глеб и Анна исследуют эффективность лекарственного препарата АВС. Глеб, используя модель Анны, создал компьютерную программу, вычисляющую по заданным генетическим факторам вероятность (в процентах) успешного применения АВС. Программа Глеба накапливает полученные вероятности и в итоге выдает набор частот: n0,n1,...,n100. Например, n75 – это число случаев, в которых программа Глеба получила вероятность 75%. Обработав 1000 образцов генетического материала, Анна нашла значения факторов и ввела их в программу. В результате был получен следующий набор частот: 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 0, 1, 1, 3, 4, 4, 5, 4, 6, 6, 11, 9, 19, 23, 25, 33, 36, 36, 46, 46, 49, 58, 90, 76, 66, 69, 75, 68, 44, 39, 21, 16, 5, 2, 1, 0, 0, 0. Для завершения этапа исследования необходимо было подобрать распределение, соответствующее полученным частотам. Анна решила использовать распределение на отрезке [0,1] с плотностью f(x)=f(x;a,b)=abxa−1(1−xa)b−1 и целочисленными параметрами a,b в диапазоне от 1 до 20. В результате максимизации функции правдоподобия (при указанных ограничениях) Глебом были получены значения параметров: a^=A и b^=B. Задача: пусть X – случайная величина, распределения на отрезке [0,1] с плотностью f(x)=f(x;a^,b^), F(x) – ее функция распределения. Требуется найти математическое ожидание E(X) и X0, 2=F−1(0,2) – квантиль уровня 0,2. Какой смысл для всей популяции имеют E(X) и X0, 2? В ответе укажите: 1) значение A; 2) значение B; 3) математическое ожидание E(X); 4) квантиль X0, 2.''')
    s = '''
N = np.array([...])
sample = []
for i, v in enumerate(N):
  sample += [i/100] * v

f = lambda a, b: a*b*sample**(a-1)*(1-sample**a)**(b-1)
def F(ab):
  return sum(np.log(f(ab[0], ab[1])))
a, b = fmin(lambda x: -F(x), [15, 3])
a, b = round(a), round(b)
print(a, b)

x = symbols('x')
f_rasp = a*b*x**(a-1)*(1-x**a)**(b-1)
f_rasp

mean = float(simplify(integrate(x*f_rasp, (x, 0, 1))))
print(mean)

kvantil = (1 - (1 - x)**(1/b))**(1/a)
print(kvantil.subs(x, 0.2))
    '''
    return pc.copy(s)


