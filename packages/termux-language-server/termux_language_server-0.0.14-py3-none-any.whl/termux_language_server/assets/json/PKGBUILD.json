{
  "$id": "https://github.com/termux/termux-language-server/blob/main/src/termux_language_server/assets/json/PKGBUILD.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$comment": "Don't edit this file directly! It is generated by `termux-language-server --generate-schema=PKGBUILD`.",
  "type": "object",
  "patternProperties": {
    "^package($|_.*)": {
      "description": "The package() function is used to install files into the directory that will become the root directory of the built package and is run after all the optional functions listed below. The packaging stage is run using fakeroot to ensure correct file permissions in the resulting package. All other functions will be run as the user calling makepkg.",
      "const": 0
    },
    "^prepare($|_.*)": {
      "description": "An optional prepare() function can be specified in which operations to prepare the sources for building, such as patching, are performed. This function is run after the source extraction and before the build() function. The prepare() function is skipped when source extraction is skipped.",
      "const": 0
    },
    "^build($|_.*)": {
      "description": "The optional build() function is used to compile and/or adjust the source files in preparation to be installed by the package() function.",
      "const": 0
    },
    "^check($|_.*)": {
      "description": "An optional check() function can be specified in which a package's test-suite may be run. This function is run between the build() and package() functions. Be sure any exotic commands used are covered by the checkdepends array.",
      "const": 0
    }
  },
  "properties": {
    "pkgname": {
      "description": "Either the name of the package or an array of names for split packages. Valid characters for members of this array are alphanumerics, and any of the following characters: \"@ . \\_ + -\". Additionally, names are not allowed to start with hyphens or dots.",
      "anyOf": [
        {
          "type": "array",
          "items": {
            "type": "string"
          },
          "uniqueItems": true
        },
        {
          "type": "string"
        }
      ]
    },
    "pkgver": {
      "description": "The version of the software as released from the author (e.g., *2.7.1*). The variable is not allowed to contain colons, forward slashes, hyphens or whitespace.\nThe pkgver variable can be automatically updated by providing a pkgver() function in the PKGBUILD that outputs the new package version. This is run after downloading and extracting the sources and running the prepare() function (if present), so it can use those files in determining the new pkgver. This is most useful when used with sources from version control systems (see below).",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "const": 0
        }
      ]
    },
    "pkgrel": {
      "description": "This is the release number specific to the distribution. This allows package maintainers to make updates to the package's configure flags, for example. This is typically set to *1* for each new upstream software release and incremented for intermediate PKGBUILD updates. The variable is a positive integer, with an optional subrelease level specified by adding another positive integer separated by a period (i.e. in the form x.y).",
      "type": "string"
    },
    "epoch": {
      "description": "Used to force the package to be seen as newer than any previous versions with a lower epoch, even if the version number would normally not trigger such an upgrade. This value is required to be a positive integer; the default value if left unspecified is *0*. This is useful when the version numbering scheme of a package changes (or is alphanumeric), breaking normal version comparison logic. See **pacman**(8) for more information on version comparisons.",
      "type": "string"
    },
    "pkgdesc": {
      "description": "This should be a brief description of the package and its functionality. Try to keep the description to one line of text and to not use the package's name.",
      "type": "string"
    },
    "url": {
      "description": "The URL to the VCS repository. This must include the VCS in the URL protocol for makepkg to recognize this as a VCS source. If the protocol does not include the VCS name, it can be added by prefixing the URL with vcs+. For example, using a Git repository over HTTPS would have a source URL in the form: git+https://\\....",
      "type": "string",
      "format": "uri"
    },
    "license": {
      "description": "This field specifies the license(s) that apply to the package. Commonly used licenses can be found in */usr/share/licenses/common*. If you see the package's license there, simply reference it in the license field (e.g., license=(GPL)). If the package provides a license not available in */usr/share/licenses/common*, then you should include it in the package itself and set license=(custom) or license=(custom:LicenseName). The license should be placed in *\\$pkgdir/usr/share/licenses/\\$pkgname/* when building the package. If multiple licenses are applicable, list all of them: license=(GPL FDL).",
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "AGPL3",
          "Apache",
          "Artistic2.0",
          "Boost",
          "CCPL",
          "CDDL",
          "CPL",
          "EPL",
          "FDL1.2",
          "FDL1.3",
          "GPL2",
          "GPL3",
          "LGPL2.1",
          "LGPL3",
          "LPPL",
          "MPL",
          "MPL2",
          "PHP",
          "PSF",
          "PerlArtistic",
          "Unlicense",
          "W3C",
          "ZPL",
          "WTFPL",
          "AGPL",
          "APACHE",
          "FDL",
          "GPL",
          "LGPL",
          "RUBY",
          "Ruby"
        ]
      },
      "uniqueItems": true
    },
    "install": {
      "description": "Specifies a special install script that is to be included in the package. This file should reside in the same directory as the PKGBUILD and will be copied into the package by makepkg. It does not need to be included in the source array (e.g., install=\\$pkgname.install).",
      "type": "string"
    },
    "changelog": {
      "description": "Specifies a changelog file that is to be included in the package. The changelog file should end in a single newline. This file should reside in the same directory as the PKGBUILD and will be copied into the package by makepkg. It does not need to be included in the source array (e.g., changelog=\\$pkgname.changelog).",
      "type": "string"
    },
    "source": {
      "description": "An array of source files required to build the package. Source files must either reside in the same directory as the PKGBUILD, or be a fully-qualified URL that makepkg can use to download the file. To simplify the maintenance of PKGBUILDs, use the \\$pkgname and \\$pkgver variables when specifying the download location, if possible. Compressed files will be extracted automatically unless found in the noextract array described below.\nAdditional architecture-specific sources can be added by appending an underscore and the architecture name e.g., *source_x86_64=()*. There must be a corresponding integrity array with checksums, e.g. *cksums_x86_64=()*.\nIt is also possible to change the name of the downloaded file, which is helpful with weird URLs and for handling multiple source files with the same name. The syntax is: source=(filename::url).\nmakepkg also supports building developmental versions of packages using sources downloaded from version control systems (VCS). For more information, see Using VCS Sources below.\nFiles in the source array with extensions .sig, .sign or, .asc are recognized by makepkg as PGP signatures and will be automatically used to verify the integrity of the corresponding source file.",
      "type": "array",
      "items": {
        "type": "string"
      },
      "uniqueItems": true
    },
    "validpgpkeys": {
      "description": "An array of PGP fingerprints. If this array is non-empty, makepkg will only accept signatures from the keys listed here and will ignore the trust values from the keyring. If the source file was signed with a subkey, makepkg will still use the primary key for comparison.\nOnly full fingerprints are accepted. They must be uppercase and must not contain whitespace characters.",
      "type": "array",
      "items": {
        "type": "string"
      },
      "uniqueItems": true
    },
    "noextract": {
      "description": "An array of file names corresponding to those from the source array. Files listed here will not be extracted with the rest of the source files. This is useful for packages that use compressed data directly.",
      "type": "array",
      "items": {
        "type": "string"
      },
      "uniqueItems": true
    },
    "cksums": {
      "description": "This array contains CRC checksums for every source file specified in the source array (in the same order). makepkg will use this to verify source file integrity during subsequent builds. If *SKIP* is put in the array in place of a normal hash, the integrity check for that source file will be skipped. To easily generate cksums, run \"makepkg -g \\>\\> PKGBUILD\". If desired, move the cksums line to an appropriate location. Note that checksums generated by \\\"makepkg -g\\\" should be verified using checksum values provided by the software developer.",
      "type": "array",
      "items": {
        "type": "string"
      },
      "uniqueItems": true
    },
    "md5sums": {
      "description": "Alternative integrity checks that makepkg supports; these all behave similar to the cksums option described above. To enable use and generation of these checksums, be sure to set up the INTEGRITY_CHECK option in **makepkg.conf**(5).",
      "type": "array",
      "items": {
        "type": "string"
      },
      "uniqueItems": true
    },
    "sha1sums": {
      "description": "Alternative integrity checks that makepkg supports; these all behave similar to the cksums option described above. To enable use and generation of these checksums, be sure to set up the INTEGRITY_CHECK option in **makepkg.conf**(5).",
      "type": "array",
      "items": {
        "type": "string"
      },
      "uniqueItems": true
    },
    "sha224sums": {
      "description": "Alternative integrity checks that makepkg supports; these all behave similar to the cksums option described above. To enable use and generation of these checksums, be sure to set up the INTEGRITY_CHECK option in **makepkg.conf**(5).",
      "type": "array",
      "items": {
        "type": "string"
      },
      "uniqueItems": true
    },
    "sha256sums": {
      "description": "Alternative integrity checks that makepkg supports; these all behave similar to the cksums option described above. To enable use and generation of these checksums, be sure to set up the INTEGRITY_CHECK option in **makepkg.conf**(5).",
      "type": "array",
      "items": {
        "type": "string"
      },
      "uniqueItems": true
    },
    "sha384sums": {
      "description": "Alternative integrity checks that makepkg supports; these all behave similar to the cksums option described above. To enable use and generation of these checksums, be sure to set up the INTEGRITY_CHECK option in **makepkg.conf**(5).",
      "type": "array",
      "items": {
        "type": "string"
      },
      "uniqueItems": true
    },
    "sha512sums": {
      "description": "Alternative integrity checks that makepkg supports; these all behave similar to the cksums option described above. To enable use and generation of these checksums, be sure to set up the INTEGRITY_CHECK option in **makepkg.conf**(5).",
      "type": "array",
      "items": {
        "type": "string"
      },
      "uniqueItems": true
    },
    "b2sums": {
      "description": "Alternative integrity checks that makepkg supports; these all behave similar to the cksums option described above. To enable use and generation of these checksums, be sure to set up the INTEGRITY_CHECK option in **makepkg.conf**(5).",
      "type": "array",
      "items": {
        "type": "string"
      },
      "uniqueItems": true
    },
    "groups": {
      "description": "An array of symbolic names that represent groups of packages, allowing you to install multiple packages by requesting a single target. For example, one could install all KDE packages by installing the *kde* group.",
      "type": "array",
      "items": {
        "type": "string"
      },
      "uniqueItems": true
    },
    "arch": {
      "description": "Defines on which architectures the given package is available (e.g., arch=(i686 x86_64)). Packages that contain no architecture specific files should use arch=(any). Valid characters for members of this array are alphanumerics and \"\\_\".",
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "any",
          "pentium4",
          "i486",
          "i686",
          "x86_64",
          "x86_64_v3",
          "arm",
          "armv6h",
          "armv7h",
          "armv8",
          "aarch64"
        ]
      },
      "uniqueItems": true
    },
    "backup": {
      "description": "An array of file names, without preceding slashes, that should be backed up if the package is removed or upgraded. This is commonly used for packages placing configuration files in */etc*. See \\\"Handling Config Files\\\" in **pacman**(8) for more information.",
      "type": "array",
      "items": {
        "type": "string"
      },
      "uniqueItems": true
    },
    "depends": {
      "description": "An array of packages this package depends on to run. Entries in this list should be surrounded with single quotes and contain at least the package name. Entries can also include a version requirement of the form *name\\<\\>version*, where \\<\\> is one of five comparisons: \\>= (greater than or equal to), \\<= (less than or equal to), = (equal to), \\> (greater than), or \\< (less than).\nIf the dependency name appears to be a library (ends with .so), makepkg will try to find a binary that depends on the library in the built package and append the version needed by the binary. Appending the version yourself disables automatic detection.\nAdditional architecture-specific depends can be added by appending an underscore and the architecture name e.g., *depends_x86_64=()*.",
      "type": "array",
      "items": {
        "type": "string"
      },
      "uniqueItems": true
    },
    "makedepends": {
      "description": "An array of packages this package depends on to build but are not needed at runtime. Packages in this list follow the same format as depends.\nAdditional architecture-specific makedepends can be added by appending an underscore and the architecture name e.g., *makedepends_x86_64=()*.",
      "type": "array",
      "items": {
        "type": "string"
      },
      "uniqueItems": true
    },
    "checkdepends": {
      "description": "An array of packages this package depends on to run its test suite but are not needed at runtime. Packages in this list follow the same format as depends. These dependencies are only considered when the check() function is present and is to be run by makepkg.\nAdditional architecture-specific checkdepends can be added by appending an underscore and the architecture name e.g., *checkdepends_x86_64=()*.",
      "type": "array",
      "items": {
        "type": "string"
      },
      "uniqueItems": true
    },
    "optdepends": {
      "description": "An array of packages (and accompanying reasons) that are not essential for base functionality, but may be necessary to make full use of the contents of this package. optdepends are currently for informational purposes only and are not utilized by pacman during dependency resolution. Packages in this list follow the same format as depends, with an optional description appended. The format for specifying optdepends descriptions is:\noptdepends=(python: for library bindings) ",
      "type": "array",
      "items": {
        "type": "string"
      },
      "uniqueItems": true
    },
    "conflicts": {
      "description": "An array of packages that will conflict with this package (i.e. they cannot both be installed at the same time). This directive follows the same format as depends. Versioned conflicts are supported using the operators as described in depends.\nAdditional architecture-specific conflicts can be added by appending an underscore and the architecture name e.g., *conflicts_x86_64=()*.",
      "type": "array",
      "items": {
        "type": "string"
      },
      "uniqueItems": true
    },
    "provides": {
      "description": "An array of \"virtual provisions\" this package provides. This allows a package to provide dependencies other than its own package name. For example, the dcron package can provide *cron*, which allows packages to depend on *cron* rather than *dcron OR fcron*.\nVersioned provisions are also possible, in the *name=version* format. For example, dcron can provide *cron=2.0* to satisfy the *cron\\>=2.0* dependency of other packages. Provisions involving the \\> and \\< operators are invalid as only specific versions of a package may be provided.\nIf the provision name appears to be a library (ends with .so), makepkg will try to find the library in the built package and append the correct version. Appending the version yourself disables automatic detection.\nAdditional architecture-specific provides can be added by appending an underscore and the architecture name e.g., *provides_x86_64=()*.",
      "type": "array",
      "items": {
        "type": "string"
      },
      "uniqueItems": true
    },
    "replaces": {
      "description": "An array of packages this package should replace. This can be used to handle renamed/combined packages. For example, if the *j2re* package is renamed to *jre*, this directive allows future upgrades to continue as expected even though the package has moved. Versioned replaces are supported using the operators as described in depends.\nSysupgrade is currently the only pacman operation that utilizes this field. A normal sync or upgrade will not use its value.\nAdditional architecture-specific replaces can be added by appending an underscore and the architecture name e.g., *replaces_x86_64=()*.",
      "type": "array",
      "items": {
        "type": "string"
      },
      "uniqueItems": true
    },
    "options": {
      "description": "This array allows you to override some of makepkg's default behavior when building packages. To set an option, just include the option name in the options array. To reverse the default behavior, place an \"!\" at the front of the option. Only specify the options you specifically want to override, the rest will be taken from **makepkg.conf**(5). **NOTE:** *force* is a now-removed option in favor of the top level *epoch* variable.\n**strip**\nStrip symbols from binaries and libraries. If you frequently use a debugger on programs or libraries, it may be helpful to disable this option.",
      "type": "array",
      "items": {
        "type": "string"
      },
      "uniqueItems": true
    },
    "srcdir": {
      "description": "This contains the directory where makepkg extracts, or copies, all source files.\nAll of the packaging functions defined above are run starting inside \\$srcdir",
      "type": "string"
    },
    "pkgdir": {
      "description": "This contains the directory where makepkg bundles the installed package. This directory will become the root directory of your built package. This variable should only be used in the package() function.",
      "type": "string"
    },
    "startdir": {
      "description": "This contains the absolute path to the directory where the PKGBUILD is located, which is usually the output of \\$(pwd) when makepkg is started. Use of this variable is deprecated and strongly discouraged.",
      "type": "string"
    },
    "pkgbase": {
      "description": "The name used to refer to the group of packages in the output of makepkg and in the naming of source-only tarballs. If not specified, the first element in the pkgname array is used. Valid characters for this variable are alphanumerics, and any of the following characters: \"@ . \\_ + -\". Additionally, the variable is not allowed to start with hyphens or dots.",
      "type": "string"
    },
    "directory": {
      "description": "(optional) Specifies an alternate directory name for makepkg to download the VCS source into.",
      "type": "string"
    },
    "fragment": {
      "description": "(optional) Allows specifying a revision number or branch for makepkg to checkout from the VCS. A fragment has the form type=value, for example to checkout a given revision the source line would be source=(url#revision=123). The available types depends on the VCS being used:\n**bzr**\nrevision (see bzr help revisionspec for details)",
      "type": "string"
    },
    "query": {
      "description": "(optional) Allows specifying whether a VCS checkout should be checked for PGP-signed revisions. The source line should have the format source=(url#fragment?signed) or source=(url?signed#fragment). Currently only supported by Git.",
      "type": "string"
    },
    "mingw_arch": {
      "type": "array",
      "description": "A list of MSYS2 environments the package is built for. Defaults to an empty list.",
      "items": {
        "type": "string",
        "enum": [
          "mingw32",
          "mingw64",
          "ucrt64",
          "clang64",
          "clang32",
          "clangarm64"
        ]
      },
      "uniqueItems": true
    },
    "msys2_internal": {
      "type": "boolean",
      "description": "Whether the package is an internal or meta package and shouldn't be linked to external sources. Defaults to false."
    },
    "msys2_references": {
      "type": "array",
      "description": "Maps the package to external resources, such as other package repositories.",
      "items": {
        "type": "string",
        "pattern": "(archlinux|aur|cygwin|cygwin-mingw64|pypi)(|: .*)"
      },
      "uniqueItems": true
    },
    "msys2_changelog_url": {
      "type": "string",
      "description": "NEWS file in git or the GitHub releases page. In case there are multiple, the one that is more useful for packagers.",
      "format": "uri"
    },
    "msys2_documentation_url": {
      "type": "string",
      "description": "URL to the documentation for the API, tools, etc., in case it's a different website than the homepage.",
      "format": "uri"
    },
    "msys2_repository_url": {
      "type": "string",
      "description": "URL to the web view of the repository, e.g., on GitHub or GitLab.",
      "format": "uri"
    },
    "msys2_issue_tracker_url": {
      "type": "string",
      "description": "URL to the bug tracker, mailing list archive, etc.",
      "format": "uri"
    },
    "msys2_pgp_keys_url": {
      "type": "string",
      "description": "URL to a website containing which keys are used to sign releases.",
      "format": "uri"
    }
  }
}
