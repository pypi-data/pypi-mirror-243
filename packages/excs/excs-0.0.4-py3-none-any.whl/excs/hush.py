# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_hush.ipynb.

# %% auto 0
__all__ = ['HushedErrors']

# %% ../nbs/04_hush.ipynb 6
#| export


# %% ../nbs/04_hush.ipynb 8
from typing import Self

# %% ../nbs/04_hush.ipynb 10
#| export


# %% ../nbs/04_hush.ipynb 12
#| export


# %% ../nbs/04_hush.ipynb 14
from .type import P, E
from .meta import ExceptionMeta
from .base import Except
from .mixs import Hushable, Aggregable

# %% ../nbs/04_hush.ipynb 16
class HushedErrors(Hushable, Aggregable):
    '''
    A custom exception class for handling multiple exceptions.

    This class allows for the aggregation of multiple exception instances,
    providing an option to either raise a combined exception or suppress it
    based on a `hush` flag. It also supports adding custom messages.

    Parameters
    ----------
    *errs : Exception
        Variable length argument list of Exception instances.
    hush : bool, optional
        A flag to determine if the exception should be raised or suppressed. 
        Default is False, which means the exception will be raised.

    Attributes
    ----------
    errs : list
        A list of Exception instances that are being handled.

    hush : bool
        Flag to determine whether to raise or suppress the exception.

    expl : str
        An explanatory message that can be prefixed to the exception string.

    eager: bool
        If eager, will raise the exception immediately when the number of errors
        exceeds the tolerance. Otherwise, will wait until `force` is called so that
        the exceptions can continue to be aggregated.

    errtol: int, default: 0
        The number of errors to tolerate before raising the exception if `eager` is True.
        Otherwise the exception will be raised only if `force` is called so that the 
        exceptions can continue to be aggregated.

    Methods
    -------
    call(self)
        Raises the exception if it is not hushed and intolerable.

    force(self)
        Raises the exception regardless if hushed or not.
                
    throw(self)
        Raises the exception if `__bool__` evaluates True.

    cause(self, cause: str)
        Updates the explanation message of the exception.

    intol(self) -> bool
        Returns True if the number of errors is greater than the tolerance.

    wait(self) -> bool
        Returns True if the number of errors is greater than the tolerance and
        the exception is not eager. Only returns False if the current state is
        "intolerable" and the exception is eager (i.e. should be raised immediately).

    hushed(self)
        Whether or not the exception should be surpressed by
        using `getattr` with a default to safely check the `hush` property.

    __init__(*errs: Exception, hush: bool = False)
        Initializes the HushedErrors instance. Accepts multiple Exception instances
        and a boolean flag to indicate whether to hush (suppress) the exception.

    msgs(*errs: Exception) -> str
        Class method. Formats and returns a string representing all provided
        exceptions in the `errs` argument.
    
    add(*errs: Exception) -> Self
        Adds additional exception instances to the `errs` list. Returns the
        modified instance for method chaining.
    
    msg(msg: str) -> Self
        Sets a custom message to be prefixed in the exception string. Returns
        the modified instance for method chaining.
    
    __str__()
        Returns a formatted string representation of the exception.
  
    call()
        Raises the exception if the `hush` attribute is set to False. This method
        is useful for conditionally raising the aggregated exceptions.

    Examples
    --------
    >>> try:
    ...     # Some operations that may raise exceptions
    ... except Exception as e:
    ...     err = HushedErrors(e, hush=True)
    ...     err.call()  # This will not raise the exception because of hush=True
    '''
    def __init__(self, *errs: Exception, hush: bool = True, expl: str = '', eager: bool = False, errtol: int = 0) -> None:
        super().__init__(hush, expl, *errs, eager=eager, errtol=errtol)

    def __str__(self) -> str:
        base = f'{type(self).__name__}'
        estr = '('
        if self.expl: estr += self.expl        

        if (nerr := len(self.errs)):
            nstr = 'err' if nerr == 1 else 'errs'
            if estr[-1] not in  ['(', ' ']: estr += ', '
            estr += f'errs={len(self.errs)}'

        if estr[-1] not in  ['(', ' ']: estr += ', '
        estr += f'eager={self.eager}'

        if self.errtol > 0:
            if estr[-1] not in ['(', ' ']: estr += ', '
            estr += f'errtol={self.errtol})'
        else:
            estr += ')'

        if nerr > 0: estr += f'\n{self.msgs(*self.errs)}'
        return f'{base}{estr}'        
    
    def __repr__(self):
        estr = str(self).split('\n')[0]
        return estr
    
    def __raise__(self):
        return not self.hushed() and not self.wait()
        

# %% ../nbs/04_hush.ipynb 25
#| export
