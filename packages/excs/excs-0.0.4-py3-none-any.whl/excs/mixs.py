# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_mixs.ipynb.

# %% auto 0
__all__ = ['Hushable', 'Aggregable']

# %% ../nbs/03_mixs.ipynb 6
#| export


# %% ../nbs/03_mixs.ipynb 8
from types import TracebackType
from typing import Self, Type, TypeVar, ParamSpec

# %% ../nbs/03_mixs.ipynb 10
#| export

# %% ../nbs/03_mixs.ipynb 12
#| export


# %% ../nbs/03_mixs.ipynb 14
from .type import P, E
from .meta import ExceptionMeta
from .base import Except

# %% ../nbs/03_mixs.ipynb 17
class Hushable(Except):
    '''
    A base exception class for creating hushable exceptions.

    Hushable exceptions can be suppressed based on a 'hush' attribute. They can
    be used as a mixin or as a decorator to make other exceptions hushable.

    Parameters
    ----------
    hush : bool
        Determines whether the exception should be suppressed.

    expl : str
        An explanation message for the exception.

    Methods
    -------
    call(self)
        Raises the exception if it is not hushed.

    force(self)
        Raises the exception regardless if hushed or not.
        
    throw(self)
        Raises the exception if it is not hushed.

    cause(self, cause: str)
        Updates the explanation message of the exception.

    hushed(self)
        Whether or not the exception should be surpressed by
        using `getattr` with a default to safely check the `hush` property.

    __raise__(self)
        The `Except`'s truth value. Used by `__bool__` to determine
        if the exception should be raised. Returns False if the exception is 
        hushed, True otherwise.
    
    __bool__(self)
        Returns False if the exception is hushed, True otherwise.
    
    __enter__(self)
        Context manager entry method.
    
    __exit__(self, exc_type, exc_value, traceback)
        Context manager exit method. Suppresses the exception if hushed.

    Examples
    --------
    >>> # Usage as a mixin
    >>> class MixedIn(Hushable):
    >>>     pass
    
    >>> # Usage as a decorator
    >>> @Hushable
    >>> class Decorated(Exception):
    >>>     pass

    >>> # Instances for demonstrating context manager
    >>> err_mix = MixedIn(hush=True)
    >>> err_dec = Decorated(hush=False)

    >>> # Hushed exceptions are suppressed when raised
    >>> with err_mix:
    >>>     raise err_mix  
    >>> # This is suppressed

    >>> # Not hushed exceptions are still raised
    >>> with err_dec:
    >>>     raise err_dec  
    >>> # This raises Decorated exception

    >>> # Subclasses of Hushable can also use `capture` to suppress exceptions
    >>> Decorated.capture(lambda: 1/0)(hush=True)  
    >>> # returns ZeroDivisionError('division by zero')
    '''
    
    def __init__(self, hush: bool = False, expl: str = '', *args, **kwargs):
        '''
        Initializes a new instance of the Hushable exception.

        Parameters
        ----------
        hush : bool, optional
            If True, the exception will be suppressed when raised. Defaults to False.
        expl : str, optional
            An optional explanation message for the exception. Defaults to the class name.
        *args
            Positional arguments to be passed to the base Exception class.
        **kwargs
            Keyword arguments to be passed to the base Exception class.
        '''
        self.hush = kwargs.pop('hush', hush)
        self.expl = kwargs.pop('expl', expl) # or type(self).__name__    
        super().__init__(*args, hush = self.hush, expl = self.expl, **kwargs)

    def __raise__(self: Self) -> bool:
        '''
        Determines the truth value of the Hushable instance.

        Returns
        -------
        bool
            Returns False if the exception is hushed (suppressed), True otherwise.
        '''
        return not self.hushed()
    
    def cause(self: Self, cause: str = '') -> Self:
        '''Update the explanation message of the exception.'''
        self.expl = cause or self.expl #or type(self).__name__
        return self
    
    def hushed(self: Self) -> bool:
        return getattr(self, 'hush', False) == True
    
    def __str__(self: Self) -> str:
        if self.expl: return f'{type(self).__name__}({self.expl})'
        return f'{type(self).__name__}'

# %% ../nbs/03_mixs.ipynb 19
class Aggregable(Except):
    '''
    A mixin class for aggregating multiple exceptions.

    This mixin provides functionality to collect multiple exception instances,
    allowing them to be raised or handled collectively.

    Attributes
    ----------
    errs : list
        A list of Exception instances that have been aggregated.

    eager: bool
        If eager, will raise the exception immediately when the number of errors
        exceeds the tolerance. Otherwise, will wait until `force` is called so that
        the exceptions can continue to be aggregated.

    errtol: int, default: 0
        The number of errors to tolerate before raising the exception if `eager` is True.
        Otherwise the exception will be raised only if `force` is called so that the 
        exceptions can continue to be aggregated.

    Methods
    -------
    call(self)
        See `throw`.

    force(self)
        Raises the exception regardless of all else.
        
    throw(self)
        Raises the exception if `__bool__` evaluates True.

    cause(self, cause: str)
        Updates the explanation message of the exception.

    intol(self) -> bool
        Returns True if the number of errors is greater than the tolerance.

    wait(self) -> bool
        Returns True if the number of errors is greater than the tolerance and
        the exception is not eager. Only returns False if the current state is
        "intolerable" and the exception is eager (i.e. should be raised immediately).

    __init__(*errs: Exception)
        Initializes the mixin with a list of Exception instances.

    __raise__(self)
        The `Except`'s truth value. Used by `__bool__` to determine
        if the exception should be raised.

    msgs(*errs: Exception) -> str
        Class method. Formats and returns a string representing all provided
        exceptions in the `errs` argument.

    add(*errs: Exception) -> Self
        Adds additional exception instances to the `errs` list. Returns the
        modified instance for method chaining.

    __str__()
        Returns a formatted string representation of the aggregated exceptions.
    '''
    def __init__(self: Self, *errs: Exception, eager: bool = False, errtol: int = 0, **kwargs) -> None:
        self.errs = list(errs)
        self.eager = eager
        self.errtol = errtol
        
        super().__init__(*errs, eager = self.eager, errtol = self.errtol, **kwargs)
        
        self.call()

    @classmethod
    def msgs(cls: Type[Self], *errs: Exception) -> str:
        '''
        Formats and returns a string representing all provided exceptions.

        This class method takes multiple Exception instances and returns a formatted
        string representing each exception's type and message.

        Parameters
        ----------
        *errs : Exception
            A variable number of Exception instances to be formatted.

        Returns
        -------
        str
            A formatted string representing each provided Exception instance.
        '''
        return '\n'.join([f'\t - {type(e).__name__}({e})' for e in errs])

    def add(self: Self, *errs: Exception) -> Self:
        '''
        Adds additional exception instances to the aggregated exceptions list.

        This method allows for dynamically adding more exceptions to the existing
        collection. It supports method chaining for convenient multiple additions.

        Parameters
        ----------
        *errs : Exception
            Variable length argument list of Exception instances to be added.

        Returns
        -------
        AggregateErrorsMixin
            The instance itself, to allow for method chaining.
        '''
        self.errs.extend(list(errs))
        self.call()
        return self

    def __str__(self: Self) -> str:
        return f'{self.msgs(*self.errs)}'
    
    def intol(self: Self) -> bool:
        '''If the number of errors is greater than the tolerance, return True.'''
        return len(self.errs) > self.errtol
    
    def wait(self: Self) -> bool:
        match (self.intol(), self.eager):
            case (True,  True):  return False # raise immediately
            case (True,  False): return True  # passed tolerance, but not eager
            case (False, True):  return True  # tolerable but eager, wait until intolerable
            case (False, False): return True  # tolerable amd not eager, wait until forced, otherwise
            # how are we to call this an aggregate error if we don't wait for more errors?
            case _: return False

    def __raise__(self: Self) -> Self:
        '''
        Determines the truth value of the Aggregable instance.

        Returns
        -------
        bool
            Returns False if the exception is hushed (suppressed), True otherwise.
        '''
        return not self.wait()

# %% ../nbs/03_mixs.ipynb 21
#| export
