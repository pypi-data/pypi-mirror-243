import os.path


def rvs(number, search=0):
        sklad = {
0:
        """
Пусть (x1,y1);...;(x37,y37)
 – реализация случайной выборки (X1,Y1);...;(X37,Y37)
 из двумерного нормального распределения N(μx;μy;σ2x;σ2y;ρ)
. Используя векторы x⃗ =(x1;...;x37)
 и y⃗ =(y1;...;y37)
, постройте асимптотический 0,77-
доверительный интервал (θˆ1;θˆ2)
 для коэффициента корреляции ρ
. В ответе укажите: 1) выборочный коэффициент корреляции ρˆ;
 2) верхнюю границу θˆ2
 построенного доверительного интервала для ρ
.
Исходные данные: x⃗
 = (-1,598; 1,067; 0,789; 0,546; -2,166; -2,004; 0,489; 0,113; -0,902; -0,776; -0,164; -0,541; 0,71; 0,082; -0,737; 0,655; 0,656; 0,498; -0,527; -0,185; 1,383; -0,283; -2,518; 0,688; 1,379; -0,254; 0,886; 0,221; -0,905; 1,209; 0,128; -0,949; 1,046; 1,272; -1,226; -0,964; -0,72),   y⃗ 
 = (-2,102; 1,429; 1,516; 0,266; -1,612; -1,665; 1,203; 0,413; -0,96; -0,431; -0,575; -0,045; 0,654; 0,773; -0,584; 0,857; 0,668; 0,751; -0,605; -0,594; 1,547; -0,045; -2,164; 1,106; 1,206; 0,388; 0,577; -0,027; -1,309; 1,045; 0,85; -0,916; 1,362; 0,694; -1,108; -0,845; -0,963).

!!!КОД:

x = np.array([-1.598, 1.067, 0.789, 0.546, -2.166, -2.004, 0.489, 0.113, -0.902, -0.776, -0.164, -0.541, 0.71,
              0.082, -0.737, 0.655, 0.656, 0.498, -0.527, -0.185, 1.383, -0.283, -2.518, 0.688, 1.379, -0.254,
              0.886, 0.221, -0.905, 1.209, 0.128, -0.949, 1.046, 1.272, -1.226, -0.964, -0.72])
y = np.array([-2.102, 1.429, 1.516, 0.266, -1.612, -1.665, 1.203, 0.413, -0.96, -0.431, -0.575, -0.045, 0.654,
              0.773, -0.584, 0.857, 0.668, 0.751, -0.605, -0.594, 1.547, -0.045, -2.164, 1.106, 1.206, 0.388,
              0.577, -0.027, -1.309, 1.045, 0.85, -0.916, 1.362, 0.694, -1.108, -0.845, -0.963])
gamma = 0.77

n = len(x)

Z = norm(0, 1)

ro_hat = np.cov(x, y, ddof=0)[0, 1] / x.std() / y.std()
ro_hat

alpha = 1 - gamma
u_left = np.arctanh(ro_hat) - 1 / np.sqrt(x.shape[0]- 3) * norm.ppf(1 - alpha / 2)
u_right = np.arctanh(ro_hat) + 1 / np.sqrt(x.shape[0] - 3) * norm.ppf(1 - alpha / 2)

print('кор коэф:', ro_hat)
print('низ, верх:', np.tanh(u_left), np.tanh(u_right))
 """,
2:
"""
Глеб и Анна исследуют эффективность лекарственного препарата АВС. Глеб, используя модель Анны, создал компьютерную программу, вычисляющую по заданным генетическим факторам вероятность (в процентах) успешного применения АВС. Программа Глеба накапливает полученные вероятности и в итоге выдает набор частот: n0,n1,...,n100
. Например, n75
 – это число случаев, в которых программа Глеба получила вероятность 75%. Обработав 1000 образцов генетического материала, Анна нашла значения факторов и ввела их в программу. В результате был получен следующий набор частот: 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 0, 1, 1, 3, 4, 4, 5, 4, 6, 6, 11, 9, 19, 23, 25, 33, 36, 36, 46, 46, 49, 58, 90, 76, 66, 69, 75, 68, 44, 39, 21, 16, 5, 2, 1, 0, 0, 0. Для завершения этапа исследования необходимо было подобрать распределение, соответствующее полученным частотам. Анна решила использовать распределение на отрезке [0,1]
 с плотностью f(x)=f(x;a,b)=abxa−1(1−xa)b−1
 и целочисленными параметрами a,b
 в диапазоне от 1 до 20. В результате максимизации функции правдоподобия (при указанных ограничениях) Глебом были получены значения параметров: a^=A
 и b^=B
. Задача: пусть X
 – случайная величина, распределения на отрезке [0,1]
 с плотностью f(x)=f(x;a^,b^)
, F(x)
 – ее функция распределения. Требуется найти математическое ожидание E(X)
 и X0, 2=F−1(0,2)
 – квантиль уровня 0,2. Какой смысл для всей популяции имеют E(X)
 и X0, 2
? В ответе укажите: 1) значение A
; 2) значение B
; 3) математическое ожидание E(X)
; 4) квантиль X0, 2

!!! КОД:

q = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 0,
     1, 1, 3, 4, 4, 5, 4, 6, 6, 11, 9, 19, 23, 25, 33, 36, 36, 46, 46, 49, 58, 90, 76, 66, 69, 75, 68,
     44, 39, 21, 16, 5, 2, 1, 0, 0, 0]
quantil = 0.2

sample = []
for i in range(len(q)):
    temp = [i] * q[i]
    sample.extend(temp)
sample = np.array(sample) / 100

def lnL(p, data):
    n = len(data)
    a, b = p
    #прологарифмировать функцию из задания
    return n * np.log(a * b) + (a - 1) * np.sum(np.log(data)) + (b - 1) * np.sum(np.log(1 - data ** a))


res = minimize(fun=lambda p, data: -lnL(p, data), x0=np.array([0.1, 0.1]), args=(sample,), method='BFGS')
a_hat, b_hat = res.x
print('a',a_hat, 'b',b_hat)

class distr(rv_continuous):
    def _pdf(self, x):
        if 0 <= x <= 1:
            # тоже функция из задания, но не лог
            return round(a_hat) * round(b_hat) * x ** (round(a_hat) - 1) * (1 - x ** round(a_hat)) ** (round(b_hat) - 1)
        return 0
X = distr()
print('X.mean', integrate.quad(lambda x: x * X._pdf(x), 0, 1))

current = 0

prec = 15
p = 0

d = 1

while p < prec:
    if X.cdf(current) <= quantil:
        current += d
    else:
        current -= d
        d /= 10
        p += 1

print('quantile', current)
""",
     }
        if search:
            numbers = []
            for i, j in sklad.items():
                if search in j:
                    numbers.append(i)
            return 'есть в этих номерах: ', numbers

        return sklad[number]
