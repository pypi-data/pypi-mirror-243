use std::path::PathBuf;
use std::path::Path;
use std::fs::File;
use std::io::Write;

fn main() {
    // Proto bindings generation
    let mut config = prost_build::Config::default();
    assert!(std::process::Command::new("env")
        .args(&["mkdir", "-p", "src/proto"])
        .spawn()
        .unwrap()
        .wait()
        .unwrap()
        .success());
    config.out_dir("src/proto");
    config.protoc_arg("--experimental_allow_proto3_optional");
    config.extern_path(".compute_sql", "::delta_sql_worker_api");
    config
        .compile_protos(
            &["src/build-deps/proto/synth_data.proto"],
            &[
                PathBuf::from("src/build-deps/proto"),
                PathBuf::from("../delta-sql-worker-api/src/build-deps/proto"),
            ],
        )
        .unwrap();
    println!("cargo:rerun-if-changed=src/build-deps/proto/synth_data.proto");

    // touch .autogenerated-files
    assert!(std::process::Command::new("env")
        .args(&["touch", "src/proto/.autogenerated-files"])
        .spawn()
        .unwrap()
        .wait()
        .unwrap()
        .success());

    let mod_content = b"\
        mod synth_data;\n\
        \n\
        pub use synth_data::*;\n\
    ";
    let dest_path = Path::new(".").join("src/proto/mod.rs");
    let mut f = File::create(&dest_path).expect("Failed to create proto/mod.rs");
    f.write_all(mod_content)
        .expect("Failed to write proto/mod.rs");
}

