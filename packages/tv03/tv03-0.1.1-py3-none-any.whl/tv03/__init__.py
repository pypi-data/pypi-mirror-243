import pyperclip as pc

def array1():
    print('''Пусть (x1,y1);...;(x37,y37) – реализация случайной выборки (X1,Y1);...;(X37,Y37) из двумерного нормального распределения N(μx;μy;σ2x;σ2y;ρ). Используя векторы x =(x1;...;x37) и y =(y1;...;y37), постройте асимптотический
0,77-доверительный интервал (θˆ1;θˆ2) для коэффициента корреляции ρ. В ответе укажите: 
1) выборочный коэффициент корреляции ρˆ;
2) верхнюю границу θˆ2 построенного доверительного интервала для ρ.

Исходные данные:
x = (-1,598; 1,067; 0,789; 0,546; -2,166; -2,004; 0,489; 0,113; -0,902; -0,776; -0,164; -0,541; 0,71; 0,082; -0,737; 0,655; 0,656; 0,498; -0,527; -0,185; 1,383; -0,283; -2,518; 0,688; 1,379; -0,254; 0,886; 0,221; -0,905; 1,209; 0,128; -0,949; 1,046; 1,272; -1,226; -0,964; -0,72),
y = (-2,102; 1,429; 1,516; 0,266; -1,612; -1,665; 1,203; 0,413; -0,96; -0,431; -0,575; -0,045; 0,654; 0,773; -0,584; 0,857; 0,668; 0,751; -0,605; -0,594; 1,547; -0,045; -2,164; 1,106; 1,206; 0,388; 0,577; -0,027; -1,309; 1,045; 0,85; -0,916; 1,362; 0,694; -1,108; -0,845; -0,963).''')
    
    s = '''
x = [-1.598, 1.067, 0.789, 0.546, -2.166, -2.004, 0.489, 0.113, -0.902, -0.776, -0.164, -0.541, 0.71, 0.082, -0.737, 0.655, 0.656, 0.498, -0.527, -0.185, 1.383, -0.283, -2.518, 0.688, 1.379, -0.254, 0.886, 0.221, -0.905, 1.209, 0.128, -0.949, 1.046, 1.272, -1.226, -0.964, -0.72]
y = [-2.102, 1.429, 1.516, 0.266, -1.612, -1.665, 1.203, 0.413, -0.96, -0.431, -0.575, -0.045, 0.654, 0.773, -0.584, 0.857, 0.668, 0.751, -0.605, -0.594, 1.547, -0.045, -2.164, 1.106, 1.206, 0.388, 0.577, -0.027, -1.309, 1.045, 0.85, -0.916, 1.362, 0.694, -1.108, -0.845, -0.963]
n = len(x)
gamma = 0.77
alpha = 1 - gamma
rhohat = np.corrcoef(x, y)[0][1]
print(f'Выборочный коэффициент корреляции = {round(rhohat, 3)}')

Z = norm(0, 1)
z_al = Z.isf(alpha/2)
z_n = np.arctanh(rhohat)
theta = np.array([np.tanh(z_n - 1/np.sqrt(n - 3) * z_al), np.tanh(z_n + 1/np.sqrt(n - 3) * z_al)])
print(f'{int(gamma * 100)}%-ный доверительный интервал: {theta.round(3)}')
    '''
    return pc.copy(s)


def array2():
    print('''Глеб и Анна исследуют эффективность лекарственного препарата АВС. Глеб, используя модель Анны, создал компьютерную программу, вычисляющую по заданным генетическим факторам вероятность (в процентах) успешного применения АВС. Программа Глеба накапливает полученные вероятности и в итоге выдает набор частот: n0,n1,...,n100. Например, n75 – это число случаев, в которых программа Глеба получила вероятность 75%. Обработав 1000 образцов генетического материала, Анна нашла значения факторов и ввела их в программу. В результате был получен следующий набор частот: 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 0, 1, 1, 3, 4, 4, 5, 4, 6, 6, 11, 9, 19, 23, 25, 33, 36, 36, 46, 46, 49, 58, 90, 76, 66, 69, 75, 68, 44, 39, 21, 16, 5, 2, 1, 0, 0, 0. Для завершения этапа исследования необходимо было подобрать распределение, соответствующее полученным частотам. Анна решила использовать распределение на отрезке [0,1] с плотностью f(x)=f(x;a,b)=abxa−1(1−xa)b−1 и целочисленными параметрами a,b в диапазоне от 1 до 20. В результате максимизации функции правдоподобия (при указанных ограничениях) Глебом были получены значения параметров: a^=A и b^=B. Задача: пусть X – случайная величина, распределения на отрезке [0,1] с плотностью f(x)=f(x;a^,b^), F(x) – ее функция распределения. Требуется найти математическое ожидание E(X) и X0, 2=F−1(0,2) – квантиль уровня 0,2. Какой смысл для всей популяции имеют E(X) и X0, 2? В ответе укажите: 1) значение A; 2) значение B; 3) математическое ожидание E(X); 4) квантиль X0, 2.''')
    s = '''

import scipy.integrate as integrate

q = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 0,
     1, 1, 3, 4, 4, 5, 4, 6, 6, 11, 9, 19, 23, 25, 33, 36, 36, 46, 46, 49, 58, 90, 76, 66, 69, 75, 68,
     44, 39, 21, 16, 5, 2, 1, 0, 0, 0]
quantile = 0.2


sample = np.array([k for k in range(len(q)) for j in range(q[k])]) / 100

def f(x, a, b):
    return a * b * x ** (a - 1) * (1 - x ** a) ** (b - 1)

def lnL(p, data):
    n = len(data)
    a, b = p
    return n * np.log(a * b) + (a - 1) * np.sum(np.log(data)) + (b - 1) * np.sum(np.log(1 - data ** a))

mx, mx_a, mx_b = 0, 0, 0

for a in range(1, 21):
    for b in range(1, 21):
        prod = lnL([a, b], sample)
        if prod > mx:
            mx = prod
            mx_a = a
            mx_b = b

class distribution(rv_continuous):
    def _pdf(self, x):
        if 0 <= x <= 1:
            return mx_a * mx_b * x ** (mx_a - 1) * (1 - x ** mx_a) ** (mx_b - 1)
        return 0

X = distribution()

E_X = integrate.quad(lambda x: x * f(x, mx_a, mx_b), 0, 1)

quant_res = 0
prec = 15
p = 0
d = 1

while p < prec:
    if X.cdf(quant_res) <= quantile:
        quant_res += d
    else:
        quant_res -= d
        d /= 10
        p += 1

print(f"A: {mx_a}, B: {mx_b}, E_X: {E_X[0]}, Квантиль: {quant_res}")
    
    '''
    return pc.copy(s)


