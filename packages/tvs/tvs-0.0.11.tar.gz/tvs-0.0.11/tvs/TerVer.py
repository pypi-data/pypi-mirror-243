def help_():
    print('''
Чтобы получить доступ к заданиям используйте метод task(принимает числа от ... до ...)
Чтобы выввести список библиотек используйте метод libs()
Задание № 1 относится к заданию "Метод макс. правд."
Задание № 2 относится к заданию "Дов. инт. для коэф. кор."
Задания с № 3 до № 10 относятся к листу №7
''')
    
def libs():
    print('''
import numpy as np
from scipy.stats import *
import scipy.integrate as integrate
import matplotlib.pyplot as plt
''')
    
def task(num):
    dc = {
        1:'''
Условие:

Глеб и Анна исследуют эффективность лекарственного препарата АВС. Глеб, используя модель Анны, создал компьютерную программу, вычисляющую по заданным генетическим факторам вероятность (в процентах) успешного применения АВС.
Программа Глеба накапливает полученные вероятности и в итоге выдает набор частот: по, 7,..., Поо. 
Например, ть - это число случаев, в которых программа Глеба получила вероятность 75%. Обработав 1000 образцов генетического материала, Анна нашла значения факторов и ввела их в программу. 
В результате был получен следующий набор частот: 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
0, 1, 0, 2, 0, 0, 1, 1, 3, 4, 4, 5, 4, 6, 6, 11, 9, 19, 23, 25, 33, 36, 36, 46, 46, 49, 
58, 90, 76, 66, 69, 75, 68, 44, 39, 21, 16, 5, 2, 1, 0, 0, 0.
Для завершения этапа исследования необходимо было подобрать распределение, соответствующее полученным частотам.
Анна решила использовать распределение на отрезке (0, 1) с плотностью f(*) = /(r; a,b) = abs° 4(1 - г*)*-1 и целочисленными параметрами а, b в диапазоне от 1 до 20. 
В результате максимизации функции правдоподобия (при указанных ограничениях) Глебом были получены значения параметров: â = Л и b = В. 
Задача: пусть Х - случайная величина, распределения на отрезке (0, 1] с плотностью /(г) = f(r; a,b), F(*) - ее функция распределения. 
Требуется найти математическое ожидание Е(Х) и X0,2 = F-4(0,2) - квантиль уровня 0,2. 
Какой смысл для всей популяции имеют Е(Х) и Хо,2? В ответе укажите: 
1) значение А; 
2) значение В; 
3) математическое ожидание Е(Х): 
4) квантиль Хо,2:

Код:
q = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 0,
     1, 1, 3, 4, 4, 5, 4, 6, 6, 11, 9, 19, 23, 25, 33, 36, 36, 46, 46, 49, 58, 90, 76, 66, 69, 75, 68,
     44, 39, 21, 16, 5, 2, 1, 0, 0, 0]
quantil = 0.2

# q = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 2, 1, 1, 0, 2, 1, 3, 5, 5, 3, 6, 3, 5,
#      8, 7, 6, 4, 7, 17, 15, 15, 13, 13, 12, 21, 24, 17, 26, 21, 27, 34, 29, 19, 22, 22, 22, 16, 13, 9, 11,
#      5, 2, 3, 0, 0, 0, 0, 0]
# quantil = 0.2

sample = []
for i in range(len(q)):
    temp = [i] * q[i]
    sample.extend(temp)
sample = np.array(sample) / 100

def f(x, a, b):
    return a * b * x ** (a - 1) * (1 - x ** a) ** (b - 1)

_____________________________
def lnL(p, data):
    n = len(data)
    a, b = p
    return n * np.log(a * b) + (a - 1) * np.sum(np.log(data)) + (b - 1) * np.sum(np.log(1 - data ** a))
_____________________________
from scipy.optimize import minimize

res = minimize(fun=lambda p, data: -lnL(p, data), x0=np.array([0.1, 0.1]), args=(sample,), method='BFGS')
a_hat, b_hat = res.x
a_hat, b_hat, round(a_hat), round(b_hat)
_____________________________
class distr(rv_continuous):
    def _pdf(self, x):
        if 0 <= x <= 1:
            return round(a_hat) * round(b_hat) * x ** (round(a_hat) - 1) * (1 - x ** round(a_hat)) ** (round(b_hat) - 1)
        return 0
_____________________________
X = distr()
_____________________________
plt.figure(figsize=(15, 5))

plt.xlim(0, 1)

plt.hist(sample, density=True, bins=50)

xx = np.linspace(0, 1, 1000)
pdf = [X.pdf(i) for i in xx]

plt.plot(xx, pdf, c='r', linewidth=5)

plt.grid(c='lightblue', linestyle='--', alpha=0.5)

plt.show()
_____________________________
integrate.quad(lambda x: x * f(x, round(a_hat), round(b_hat)), 0, 1)
_____________________________
current = 0

prec = 15
p = 0

d = 1

while p < prec:
    if X.cdf(current) <= quantil:
        current += d
    else:
        current -= d
        d /= 10
        p += 1
    
current
''',
2:'''
Условие:

Пусть (21, 91);...; (231›Уз1) - реализация случайной выборки (X,, Yj);...; (Хз1, Уз1) из двумерного нормального распределения N(Mz; м,; о}; о}; р). 
Используя векторы 2 — (215..; хз1) и з = (уг;.. ;Уз1), постройте асимптотический 0,93-доверительный интервал (01;02) для коэффициента корреляции р. 
В ответе укажите: 1) выборочный коэффициент корреляции р; 
2) верхнюю границу 0, построенного доверительного интервала для р.
Исходные данные: * = (-0,616; -0,238; 0,173; -0,255; 0,531; 0,718; -0,161; 0,371; -1,014; -0,413; -1,571; 0,485; 0,486; 0,688; -0,944; 0,155; 0,003; 0,111; 0,752; 0,783; -0,102; -0,74; -2,097; 1,349; -0,044; -0,617; -0,782; -0,873; -0,995; -1,256; -0,596), y = (-1,34; -0,25;
0,101; -0,626; -0,088; 0,539; -0,451; 0,233; -1,186; -0,423; -1,329: 0,231: 0,209; 0,638; -0,274; -0,491; -0,319; 0,294; 0,895; 1,164; -0,57; -1,078; -1,526; 1,491: 0,182: -0,31; -1,001; -0,969: -0,918; -0,904; -0,595).

Код:
x = np.array([-0.616, -0.238, 0.173, -0.255, 0.531, 0.718, -0.161, 0.371, -1.014, -0.413, -1.571, 0.485,
              0.486, 0.688, -0.944, 0.155, 0.003, 0.111, 0.752, 0.783, -0.102, -0.74, -2.097, 1.349, -0.044,
              -0.617, -0.782, -0.873, -0.995, -1.256, -0.596])
y = np.array([-1.34, -0.25, 0.101, -0.626, -0.088, 0.539, -0.451, 0.233, -1.186, -0.423, -1.329, 0.231,
              0.209, 0.638, -0.274, -0.491, -0.319, 0.294, 0.895, 1.164, -0.57, -1.078, -1.526, 1.491, 0.182,
              -0.31, -1.001, -0.969, -0.918, -0.904, -0.595])
gamma = 0.93

# x = np.array([-1.598, 1.067, 0.789, 0.546, -2.166, -2.004, 0.489, 0.113, -0.902, -0.776, -0.164, -0.541, 0.71,
#               0.082, -0.737, 0.655, 0.656, 0.498, -0.527, -0.185, 1.383, -0.283, -2.518, 0.688, 1.379, -0.254,
#               0.886, 0.221, -0.905, 1.209, 0.128, -0.949, 1.046, 1.272, -1.226, -0.964, -0.72])
# y = np.array([-2.102, 1.429, 1.516, 0.266, -1.612, -1.665, 1.203, 0.413, -0.96, -0.431, -0.575, -0.045, 0.654,
#               0.773, -0.584, 0.857, 0.668, 0.751, -0.605, -0.594, 1.547, -0.045, -2.164, 1.106, 1.206, 0.388,
#               0.577, -0.027, -1.309, 1.045, 0.85, -0.916, 1.362, 0.694, -1.108, -0.845, -0.963])
# gamma = 0.77

n = len(x)

Z = norm(0, 1)

ro_hat = np.cov(x, y, ddof=0)[0, 1] / x.std() / y.std()
ro_hat

u_left = np.arctanh(ro_hat) - 1 / np.sqrt(n - 3) * Z.isf((1 - gamma) / 2)
u_right = np.arctanh(ro_hat) + 1 / np.sqrt(n - 3) * Z.isf((1 - gamma) / 2)

np.tanh(u_left), np.tanh(u_right)
__________________________________
ro_hat
''',
3:'''
Условие:

Пусть X1, X2, . . . , Xn – выборка из дискретного распределения
P θ(X1 = −1) = 2θ, P θ(X1 = 1) = 2θ,
P θ(X1 = 2) = θ, P θ(X1 = 0) = 1 − 5θ, θ ∈ (0; 1
5
).
Найдите оценку параметра θ по методу максимального правдоподобия.
Проверить полученную оценку на несмещенность и состоятельность.

Код:

t = 0.1
v = np.array([-1, 0, 1, 2])
p = np.array([2 * t, 1 - 5 * t, 2 * t, t])

X = rv_discrete(values=(v, p))
__________________________________
N = 100

sample = X.rvs(size=N)

sample
__________________________________
n2 = sp.symbols('n2')

f = (n - n2) / teta - 5 * n2 / (1 - 5 * teta)
f
__________________________________
sp.solve(f, teta)[0]
__________________________________
(N - len(sample[sample == 0])) / 5 / N
''', 
4:'''
Условие:

Пусть X1, X2, . . . Xn – выборка из Γ(1, λ)-распределения, плотность которого (напомним) задается в виде
f(x) =1\Γ(λ)^e^−x * x^λ−1, x > 0; or 0, x 6 0.
Написать уравнение максимального правдоподобия для оценки параметра λ. Найти оценку λˆ параметра λ, используя численные методы, для реализации выборки

...

Построить график функции правдоподобия (и ее логарифм)

Код:
sample = np.array([6.74348, 3.93051, 6.72063, 4.14899, 3.64511, 6.59035, 3.59793,
6.5809, 5.12561, 4.8383, 5.1555, 7.92425, 7.84539, 7.04955, 5.00687,
4.49564, 5.02336, 4.59321, 2.45032, 8.07116, 4.69684, 8.20604,
9.42367, 8.26365, 2.72062, 5.56433, 1.87337, 6.35261, 1.97432,
4.56908, 6.39021, 8.4757, 4.77942, 3.19108, 6.97562, 9.33791,
3.00108, 3.0248, 6.9238, 4.33534, 4.44541, 6.10264, 3.34966, 5.93498,
12.474, 4.84062, 3.75677, 7.75301, 2.86758, 4.56388, 2.74132,
5.97667, 2.76106, 4.29834, 13.0064, 5.67736, 4.1344, 4.17623,
5.20321, 2.60971, 6.83748, 5.4506, 4.73761, 4.69527, 9.88338,
5.48915, 6.58642, 7.22878, 5.38608, 9.08009, 5.71995, 8.25966,
7.57421, 5.21986, 2.25692, 7.20102, 6.31931, 4.81176, 5.59663,
7.52932, 2.39608, 2.07021, 5.77452, 9.28159, 4.07254, 3.22207,
4.87043, 6.92726, 5.89108, 4.41516, 4.19383, 6.72437, 8.02389,
5.38766, 3.56919, 5.60499, 4.14681, 3.71408, 9.26791, 3.97992])

sample
__________________________________
from scipy.special import gamma

l = 3.27

class distr(rv_continuous):
    def _pdf(self, x):
        if x > 0:
            return 1 / gamma(l) * sp.E ** - x * x ** (l - 1)
        return 0
__________________________________
X = distr()

sampl = X.rvs(size=10)
sampl
__________________________________
from scipy.stats import gamma

sampl = gamma(l).rvs(size=10000)

sampl
__________________________________
from scipy.special import digamma

digamma(l)
__________________________________
def f(x):
    return digamma(x) - (np.log(sampl)).mean()
__________________________________
from scipy.optimize import fsolve
__________________________________
fsolve(f, 0.4)[0], l
__________________________________
def f(x):
    return digamma(x) - (np.log(sample)).mean()

fsolve(f, 0.4)[0]
''',
5:'''
Условие:

Методом максимального правдоподобия найти оценки параметров a и b в
параметрической модели распределения Коши
f(x) = b\π[b^2 + (x − a)^2] , b > 0, a ∈ R, для выборки ...

Код:
v = np.array([1.55992, 43.2871, 2.16074, 141.461, 21.8806, 789.103, 3.38349,
1.4301, 4.65028, 5.52295, 1.99389, 2.89912, 3.27455, -0.97966,
-1.29387, 3.19466, 2.69071, -13.4734, 2.60047, 2.4326, -9.81549,
-6.7011, 7.25876, 3.80736, 5.8334, -5.69205, 2.12113, 7.19453,
4.47766, 6.30852, 1.65032, 2.0556, 2.82256, 10.7818, -18.6957,
-14.6507, 3.8727, 0.0355214, -1.94195, -21.8609, 3.56743, 26.9564,
6.57674, 2.07393, 14.5048, -5.26786, 4.23976, -1.01941, -0.570729,
-14.8699, 5.67471, -0.285076, 3.79854, 3.41434, -0.483942, -14.3194,
1.32465, -0.00208467, 1.88125, -2.5221, 1.71194, -17.8143, 1.52726,
4.11685, -1.55211, -8.20171, -4.44914, 3.97162, -17.8141, 4.64827,
5.35789, 1.90477, 0.0930849, 4.70019, -13.379, 4.36651, -4.11415,
-8.60035, -11.5259, -3.02139, 11.7426, 3.08539, 2.74418, 2.45758,
-0.962123, -75.5719, -0.753557, 4.24318, 1.38095, 1.3298, 7.38925,
-27.0796, -12.5197, 4.4771, 83.4916, 9.00757, 4.50623, -2.42047,
3.23398, 7.88624])

n = len(v)
n
__________________________________
def f(parameters):
    a, b = parameters
    return np.array([
        2 * np.sum((v - a) / (b ** 2 + (v - a) ** 2)),
        n / b - 2 * np.sum(b / (b ** 2 + (v - a) ** 2))
    ])
__________________________________
a_hat, b_hat = fsolve(f, [1, 2])
a_hat, b_hat
__________________________________
%matplotlib notebook

a = np.linspace(2.2, 2.6, 100)
b = np.linspace(2.8, 3.2, 100)
a, b = np.meshgrid(a, b)

# lnL = np.log(b) - np.log(np.pi) - np.mean(np.log(b ** 2 + (v - a) ** 2)) # тоже рабочий вариант
lnL = - n * np.log(np.pi) + np.sum(np.log(b / (b ** 2 + (v - a) ** 2)), axis=1)

lnL = np.zeros_like(a)
for i in range(len(a)): 
    for j in range(len(b)):
        lnL[i, j] = np.log(b[i, j]) - np.log(np.pi) - np.mean(np.log(b[i, j] ** 2 + (v - a[i, j]) ** 2))

fig = plt.figure(figsize=(10, 10))
ax = fig.add_subplot(projection='3d')

dot_lnL = np.log(b_hat) - np.log(np.pi) - np.mean(np.log(b_hat ** 2 + (v - a_hat) ** 2)) # точка

ax.scatter(a_hat, b_hat, dot_lnL, color='red', s=200) # рисуем точку

ax.view_init(20, 210)

ax.plot_surface(a, b, lnL, cmap='summer');
''',
6:'''
Условие:

Пусть {(X1, Y1),(X2, Y2), . . . ,(Xn, Yn)} – выборка из двумерного нормальннго распределения N (Что - то сложное)
с неизвестными параметрами θ1 = σ^2 > 0 и θ2 = ρ ∈ (−1; 1). Построить
оценки максимального правдоподобия σ^2_hat и ρ_hat.

Код: 

sigma, ro, y, A, B, C, x, y, n = sp.symbols('sigma rho y A B C x y n')
__________________________________
lnL = -n * sp.log(2 * sp.pi) - n * sp.log(x) - n / 2 * sp.log(1 - y ** 2) - n / (2 * x * (1 - y ** 2)) * (A + B - 2 * y * C)
lnL
__________________________________
dx = sp.Derivative(lnL, x, evaluate=True)
dx
__________________________________
dy = sp.Derivative(lnL, y, evaluate=True)
dy
__________________________________
res = sp.solve([dx, dy], [x, y])[0]
res[0] # sigma**2
__________________________________
res[1] # rho
''',
7:'''
Условие:

5. Пусть {(X1, Y1),(X2, Y2), . . . ,(Xn, Yn)} – выборка из двумерного нормального распределения N
(E (X); E(Y ));
Var(X) Cov(X,Y )
Cov(X,Y ) Var(Y )
= N
еизвестным параметром θ = ρ ∈ (−1; 1). Составить уравнение правдободобия для определения оценки максимального правдободобия ρb.
∗ Реализуйте на Python widget для обоих графиков (для логарифма функции
правдободобия и его производной, параметры widget A, B, C).

Код:
sigma, ro, y, A, B, C, x, y, n = sp.symbols('sigma rho y A B C x y n')
__________________________________
lnL = -sp.ln(2 * sp.pi) - 1/2 * sp.ln(1 - ro ** 2) - (A - 2 * ro * C + B) / (2 * (1 - ro ** 2))
lnL
__________________________________
dr = sp.Derivative(lnL, ro, evaluate=True).simplify()
dr
__________________________________
# после ручного преобразования
dr = ro * (1 - ro ** 2) + (ro ** 2 + 1) * C - ro * (A + B)
dr
__________________________________
res = sp.solve(dr, ro)
res[0]
__________________________________
res[1] # содержит i - комплексный корень
__________________________________
res[2] # содержит i - комплексный корень
__________________________________
f = sp.lambdify([A, B, C], res[0]) # можно из симпаевских символов преобразовать в лямбда-функцию
__________________________________
f(3, 2, 3)
__________________________________
%matplotlib notebook 
# вместо inline режима (только PNG картинки) выставляем notebook (интерактивный)
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.widgets import Slider
np.seterr(divide = 'ignore') # убираем сообщения об ошибках деления на 0, так как возникнут при rho = +-1
np.seterr(invalid = 'ignore')
 
x = np.linspace(-1, 1, 1000)
A_ = 0
B_ = 0.1
C_ = 0.03


def f_lnL(x):
    return -np.log(2 * np.pi) - 1/2 * np.log(1 - x ** 2) - (A_ - 2 * x * C_ + B_) / (2 * (1 - x ** 2))


def f_dlnL(x):
    return x * (1 - x ** 2) + (x ** 2 + 1) * C_ - x * (A_ + B_)
 
    
fig, ax = plt.subplots(figsize=(7, 7))

ax.grid(c='lightblue', linestyle='--', alpha=0.4)
ax.set_ylim(-4, 2)
fig.subplots_adjust(bottom=0.125) # вызволяем 12.5% места снизу
l, = ax.plot(x, f_lnL(x)) # график lnL
dl, = ax.plot(x, f_dlnL(x), c='red', linestyle='--') # график derivate lnL


def update_data(): # вспомогательная функция для обновления данных графика
    l.set_ydata(f_lnL(x))
    dl.set_ydata(f_dlnL(x))
    fig.canvas.draw_idle()

### Slider A
slideraxisA = fig.add_axes([0.1, 0.05, 0.8, 0.03])
 
def onChange_A(value):
    global A_
    A_ = value
    update_data()

sliderA = Slider(slideraxisA, label='A',
                valmin=0, valmax=1, valinit=A_)
sliderA.on_changed(onChange_A)
###

### Slider B
slideraxisB = fig.add_axes([0.1, 0.025, 0.8, 0.03])

def onChange_B(value):
    global B_
    B_ = value
    update_data()

sliderB = Slider(slideraxisB, label='B',
                valmin=0, valmax=1, valinit=B_)
sliderB.on_changed(onChange_B)
###

### Slider C
slideraxisC = fig.add_axes([0.1, 0, 0.8, 0.03])

def onChange_C(value):
    global C_
    C_ = value
    update_data()

sliderC = Slider(slideraxisC, label='C',
                valmin=-1, valmax=1, valinit=C_)
sliderC.on_changed(onChange_C)
###

plt.show()
''',
8:'''
Условие:
........
– выборка из двумерного нормального распределения N
(0; 0);
σ
2 ρσ2
ρσ2 σ
2
с неизвестными параметрами θ1 = σ
2 > 0 и θ2 = ρ ∈ (−1; 1). Построить
оценки максимального правдоподобия σb
2 и ρb.

Код:

v = np.array([(-0.313894, 0.438015),(0.224722, -0.449328),(-0.639293, -0.363361),
(-0.167994, 0.20571),(0.0522341, 0.138561),(-0.254661, 0.201998),
(0.0442204, -0.112244),(0.228834, 0.519609),(0.0228787, 0.56386),
(0.385821, -0.218754),(-0.232476, -0.146833),(0.243587, -0.221924),
(0.265534, -0.260073),(-0.269157, 0.336143),(-0.0271373, -0.226327),
(0.153953, -0.0805482),(0.32428, -0.200066),(0.277462, -0.192794),
(0.499289, 0.50847),(0.0959331, 0.166319),(0.202464, -0.434938),
(0.0728366, 0.269327),(-0.340479, -0.414939),(-0.417083, 0.0375611),
(-0.246902, 0.11803),(-0.234504, -0.0344259),(-0.0546271, 0.567266),
(0.0739474, 0.533507),(0.183865, -0.0358313),(-0.258409, 0.292343),
(0.176683, 0.188972),(-0.646468, -0.127734),(0.761451, 0.273523),
(0.0708475, 0.183211),(-0.649315, 0.0842457),(0.454164, -0.120189),
(0.083444, 0.136907),(-0.50404, 0.344105),(0.306273, 0.504922),
(0.0915694, -0.363476),(-0.176519, 0.185783),(0.198926, -0.142638),
(-0.403642, 0.0596804),(0.572447, 0.123529),(0.0274817, -0.284917),
(0.407448, 0.28937),(-0.225413, -0.77905),(-0.254338, 0.335472),
(-0.102176, -0.13015),(-0.0889893, 0.16551),(0.352058, 0.252975),
(-0.158156, 0.189951),(-0.319835, 0.196627),(0.123115, 0.171234),
(0.132341, -0.00637201),(0.28239, -0.498863),(0.0890051, -0.326061),
(-0.148438, 0.0429142),(0.571535, 0.416794),(0.0371119, 0.460548),
(0.273852, 0.0160622),(-0.339359, -0.0626746),(0.440342, 0.538688),
(0.0628227, 0.0194897),(0.443774, 0.373888),(0.280735, -0.0541218),
(0.0885035, -0.491287),(0.0734594, -0.0738522),(0.186268, 0.0396739),
(-0.121944, 0.243752),(-0.131286, 0.0808547),(-0.0165996, 0.213765),
(0.222346, -0.0190641),(-0.139473, -0.502365),(-0.0619227, -0.434108),
(0.182899, 0.0912378),(-0.0910926, 0.117352),(-0.383352, 0.0537915),
(0.340066, 0.213886),(-0.263456, -0.0674588),(-0.27111, -0.306004),
(-0.188309, 0.203076),(0.0918992, 0.233086),(0.213978, 0.00972123),
(-0.10169, -0.303658),(-0.074131, 0.297038),(-0.335425, -0.275405),
(0.199969, 0.404614),(-0.194719, -0.504087),(-0.124675, -0.201565),
(0.481352, 0.0167409),(0.417754, -0.0899433),(-0.215485, -0.102225),
(-0.105139, -0.449874),(0.389487, -0.578755),(-0.585644, 0.01085),
(-0.493355, 0.167084),(-0.225548, 0.0896084),(0.0628588, 0.0552897),
(0.154798, -0.0499213)])
n = len(v)
n
__________________________________
A_summ = np.mean(v[:, 0] ** 2)
B_summ = np.mean(v[:, 1] ** 2)
C_summ = np.mean(v[:, 0] * v[:, 1])
__________________________________
# из задачи 7.4
s_hat = np.sqrt(0.5 * (A_summ + B_summ))
r_hat = 2 * C_summ / (A_summ + B_summ)
s_hat, r_hat
''',
9:'''
Условие:
выборка из двумерного нормального распределения
N   (E (X); E(Y ));
Var(X) Cov(X,Y )
Cov(X,Y ) Var(Y )
= N

с неизвестным параметром θ = ρ ∈ (−1; 1). Составить уравнение правдободобия для определения оценки максимального правдободобия ρb, построить график функции логарифма правдободобия ln(L) и найти точку
максимума (оценку ρb) и максимальное значение функции правдободобия
ln(L(ρb)).

Код:

v = np.array([(-0.268523, 0.0386559),(1.29986, -1.49044),(-1.6886, 2.06954),
(-0.0687347, 1.09363),(1.22105, -0.482343),(1.74771, -1.32927),
(-2.18655, 2.04526),(-0.687599, 0.404255),(0.953435, -1.32011),
(0.25894, -0.790966),(0.379161, -0.562197),(0.98668, -0.661528),
(-1.20283, 2.27018),(-0.347196, 1.47751),(-1.15284, 0.639898),
(-0.619065, 0.519958),(0.551349, -1.1599),(-1.03084, 0.938136),
(0.694642, 0.076791),(-0.455605, -0.00791237),(-0.333623, -0.3641),
(0.794195, -1.62704),(0.628762, -1.05337),(0.23988, 0.108679),
(0.512522, -0.566078),(-1.34909, 0.904269),(1.23684, -0.999332),
(1.03058, -1.22815),(0.211958, -0.942076),(-0.216483, 0.251211),
(0.586307, -0.679991),(0.367283, -0.778627),(1.45236, -0.93682),
(0.795358, -0.099683),(-0.305742, 0.649632),(-0.136507, 0.452355),
(0.12809, 0.071605),(1.20718, -1.38198),(0.891508, -1.20897),
(-1.28457, 0.764445),(0.271594, -0.13651),(-0.925947, -0.0756929),
(-0.480537, 0.150918),(-0.0719798, -0.0795635),(-0.244393, 0.669902),
(-0.306057, -0.0858645),(0.759248, -0.914485),(-1.32424, 1.72442),
(0.660032, -1.2177),(0.733812, -0.923069),(0.0508766, -0.831884),
(-1.07985, 1.06258),(-0.161302, 0.764412),(-1.25887, 1.19168),
(0.933851, -1.33565),(-0.517722, -0.129201),(1.20779, -1.29415),
(1.0197, -0.581663),(1.00959, -0.584449),(-0.287654, 0.731749),
(-0.223508, 0.736815),(0.928122, -0.89619),(2.26748, -1.74714),
(0.0751242, 0.119896),(0.196256, -0.542241),(0.447168, -0.944736),
(-1.42807, 1.57901),(0.425185, 0.192143),(0.146784, -0.459949),
(-0.0776606, -0.756527),(0.711833, -0.710833),(0.352986, -0.69948),
(0.1521, -0.362122),(0.445771, -0.752946),(-0.411752, 0.555596),
(1.25269, -1.21343),(-1.06423, 0.98747),(0.191214, 0.464139),
(-0.00336045, -0.443947),(-0.372894, 0.487223),(1.53541, -1.5556),
(0.617677, -0.14769),(-0.787122, 0.554023),(-1.50079, 1.07711),
(-1.37406, 1.15265),(-0.591894, 0.579114),(-0.7178, 0.504307),
(-0.496436, 0.822344),(-1.45937, 0.964984),(-1.63059, 1.70014),
(-1.25601, 1.0497),(-0.454112, -0.432887),(1.02, -1.27614),
(-0.592398, 1.03948),(-0.995351, 0.210806),(0.573766, -0.805592),
(0.00928827, 0.220371),(-2.25845, 2.37796),(-0.560598, 0.0168904),
(0.507364, -0.39136)])

n = len(v)
n
__________________________________
A_summ = np.mean(v[:, 0] ** 2)
B_summ = np.mean(v[:, 1] ** 2)
C_summ = np.mean(v[:, 0] * v[:, 1])
__________________________________
lnL = -n * sp.ln(2 * sp.pi) - n / 2 * sp.ln(1 - ro ** 2) - n * (A_summ - 2 * ro * C_summ + B_summ) / (2 * (1 - ro ** 2))
lnL
__________________________________
dr = ro * (1 - ro ** 2) + (ro ** 2 + 1) * C_summ - ro * (A_summ + B_summ)
dr
__________________________________
res = sp.solve(dr, ro)
r_hat = res[0]
r_hat
__________________________________
def f_lnL(x):
    return -n * np.log(2 * np.pi) - n / 2 * np.log(1 - x ** 2) - n * (A_summ - 2 * x * C_summ + B_summ) / (2 * (1 - x ** 2))

f_lnL(float(r_hat))
__________________________________
%matplotlib notebook

np.seterr(divide = 'ignore')
np.seterr(invalid = 'ignore')
 
x = np.linspace(-1, 1, 1000)
A_ = 0
B_ = 0.1
C_ = 0.03
    
fig, ax = plt.subplots(figsize=(7, 7))
ax.grid(c='lightblue', linestyle='--', alpha=0.4)
ax.set_ylim(-500, -150)

ax.plot(x, f_lnL(x))
ax.plot(float(r_hat), f_lnL(float(r_hat)), c='red', marker='o', markersize=5)

plt.show()
''',
10:'''
Условие:

По выборке (файл DataSetFor_7_8.csv) из распределения Кумарасвами
(Kumaraswamy distribution), плотность которого определяется формулой
f(x, a, b) = 
abxa−1
(1 − x
a
)
b−1
, x ∈ (0; 1),
0, x /∈ (0; 1).
с неизвестными параметрами (θ1; θ2) = (a; b), a > 0, b > 0 найдите: 1) уравнение правдободобия для определения оценок ba и bb. 2) Используя численные методы решения нелинейных уравнений (например, метод Бройдена
– Флетчера – Гольдфарба – Шанно (BFGS, Broyden – Fletcher – Goldfarb
– Shanno algorithm)), найдите оценки ba и bb неизвестных параметров a и b.
3) Постройте гистограмму плотности относительных частот и наложите
график плотности распределения f(x, ba,bb).

Код:

import pandas as pd

sample = np.array(pd.read_csv('DataSetFor_7_8.csv', header=None, decimal=',', sep=';',encoding='cp1251')[0])
sample
__________________________________
def lnL(p, data):
    n = len(data)
    a, b = p
    return n * np.log(a * b) + (a - 1) * np.sum(np.log(data)) + (b - 1) * np.sum(np.log(1 - data ** a))
__________________________________
from scipy.optimize import minimize

res = minimize(fun=lambda p, data: -lnL(p, data), x0=np.array([0.1, 0.1]), args=(sample,), method='BFGS')
a_hat, b_hat = res.x
a_hat, b_hat
__________________________________
def kumaraswamy_pdf(x, a, b):
    return a * b * x ** (a - 1) * (1 - x ** a) ** (b - 1)
__________________________________
plt.figure(figsize=(15, 5))

plt.xlim(0, 1)

plt.hist(sample, density=True, bins=50)

xx = np.linspace(0, 1, 1000)

plt.plot(xx, kumaraswamy_pdf(xx, a_hat, b_hat), c='r', linewidth=5)

plt.grid(c='lightblue', linestyle='--', alpha=0.5)

plt.show()
'''}
    print(dc[num])

help_()