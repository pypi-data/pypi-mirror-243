# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/30_slcs.ipynb.

# %% auto 0
__all__ = ['sdim', 'makeslcs', 'slcten', 'setslcs', 'slcswith', 'slcloc', 'slcval']

# %% ../nbs/30_slcs.ipynb 6
#| export


# %% ../nbs/30_slcs.ipynb 8
#| export


# %% ../nbs/30_slcs.ipynb 10
#| export


# %% ../nbs/30_slcs.ipynb 12
#| export


# %% ../nbs/30_slcs.ipynb 14
try: import torch
except: ...

# %% ../nbs/30_slcs.ipynb 15
try: import torchvision.transforms.functional as F
except: ...

# %% ../nbs/30_slcs.ipynb 17
from atyp import (Tensor, IntQ, BoolTensor, Slcs, AxesQ, Size, Numeric,)
from chck import isiter, isnone, notnone
from asto import asslc

# %% ../nbs/30_slcs.ipynb 19
from .enum import SliceFormat
from .util import nans

# %% ../nbs/30_slcs.ipynb 21
def sdim(*slcs: Slcs, axes: AxesQ = None, ndim: IntQ = None) -> int:
     '''
     Calculate the number of dimensions to which the slices apply.

     Parameters
     ----------
     slcs : Slcs
          The slices for which the dimensionality is to be determined.

     axes : AxesQ, optional
          The axes that the slices apply to, defaults to None.

     ndim : IntQ, optional
          The number of dimensions of the target tensor, defaults to None.

     Returns
     -------
     int
          The number of dimensions to which the slices apply.

     Examples
     --------
     >>> sdim((0, 10), (0, 10))
     2
     '''
     if notnone(ndim): return ndim
     if isnone(axes): return len(slcs)
     if isiter(axes): return max(max(axes) + 1, len(axes))
     return axes

# %% ../nbs/30_slcs.ipynb 22
def makeslcs(
    *slcs: Slcs, axes: AxesQ = None, ndim: IntQ = None, 
    fmt: SliceFormat = SliceFormat.slice,
) -> list[slice]:     
    '''
    Convert tuples representing slices into actual Python slice objects.

    Parameters
    ----------
    slcs : Slcs
        Tuples representing the slices.
        
    axes : AxesQ, optional
        The axes that the slices apply to, defaults to None.

    ndim : IntQ, optional
        The number of dimensions of the target tensor, defaults to None.

    fmt : SliceFormat, optional
        The format of the slices, either 'coord' or 'slice', defaults to 'slice'.

    Returns
    -------
    list[slice]
        A list of Python slice objects.

    Examples
    --------
    >>> makeslcs((0, 10), (0, 10))
    [slice(0, 10, None), slice(0, 10, None)]
    '''
    # (x0, y0), (x1, y1) --> (x0, x1), (y0, y1)
    if isnone(fmt): fmt = SliceFormat.guess(*slcs)
    if fmt == SliceFormat.coord: slcs = SliceFormat.flip(*slcs)

    # Convert slcs tuples into slices
    slices = list(asslc(slc, __nones_ok=True) for slc in slcs)
    nslice = sdim(*slices, axes=axes, ndim=ndim)
    
    # Create a list of slice(None) for all dimensions
    axes = list([slice(None)] * nslice if isnone(axes) else axes)

    # Replace slices for specified axes
    slices = [slices[axes.index(i)] if i in axes else slice(None) for i in range(nslice)]
    return slices

# %% ../nbs/30_slcs.ipynb 23
def slcten(
    tens: Tensor, *slcs: Slcs, axes: AxesQ = None, fmt: SliceFormat = SliceFormat.slice,
    inplace: bool = True, __setval: tuple = None, __retsub: bool = True
) -> Tensor:
    '''
    Extract or modify a subslice of a tensor based on provided slice specifications.

    Parameters
    ----------
    tens : Tensor
        The tensor to slice or modify.
    slcs : Slcs
        Tuples representing the slices.
    axes : AxesQ, optional
        The axes that the slices apply to, defaults to None.
    fmt : SliceFormat, optional
        The format of the slices, either 'coord' or 'slice', defaults to 'slice'.
    inplace : bool, optional
        If True, modify the tensor in place, defaults to True.
    __setval : tuple, optional
        The value to set the sliced region to, defaults to None.
    __retsub : bool, optional
        If True, return the sliced part of the tensor, defaults to True.

    Returns
    -------
    Tensor
        The modified or extracted part of the tensor.

    Examples
    --------
    >>> slcten(torch.tensor([[1, 2], [3, 4]]), (0, 1), axes=(0,))
    tensor([[1, 2]])
    '''
    if isnone(axes): axes = (0, 1) if tens.ndim <= 3 else (1, 2)    
    slcs = makeslcs(*slcs, axes=axes, ndim=tens.ndim, fmt=fmt)
    tout = tens[slcs] if __retsub else tens
    if notnone(__setval) and __retsub:
        return torch.ones_like(tout) * torch.tensor(__setval)
    
    tout = tens.clone() if not inplace else tout
    if notnone(__setval):
        tout[slcs] = torch.tensor(__setval)
        return tout
    return tout

# %% ../nbs/30_slcs.ipynb 24
def setslcs(
    ten: Tensor, *slcs: Slcs, axes: AxesQ = None, fmt: SliceFormat = SliceFormat.slice,
    val: tuple = torch.nan, inplace: bool = False
) -> Tensor:
    '''
    Apply a mask to a tensor (i.e. set `value` to the specified slices).

    Parameters
    ----------
    ten : Tensor
        The tensor to modify.

    slcs : Slcs
        Tuples representing the slices.

    axes : AxesQ, optional
        The axes that the slices apply to, defaults to None.

    fmt : SliceFormat, optional
        The format of the slices, either 'coord' or 'slice', defaults to 'slice'.

    val : tuple, optional
        The value to apply to the slices, defaults to NaN.
        
    inplace : bool, optional
        If True, modify the tensor in place, defaults to False.

    Returns
    -------
    Tensor
        The modified tensor.

    Examples
    --------
    >>> setslcs(torch.tensor([[1, 2], [3, 4]]), (0, 1), axes=(0,), val=0)
    tensor([[0, 0], [3, 4]])
    '''
    return slcten(ten, *slcs, axes=axes, fmt=fmt, inplace=inplace, __setval=val, __retsub=False)

# %% ../nbs/30_slcs.ipynb 25
def slcswith( 
     *slcs: Slcs, size: Size = (400, 400, 3), axes: AxesQ = None,
     fmt: SliceFormat = SliceFormat.slice, val: tuple = torch.nan, 
     ttype: Numeric | type = torch.nan,
) -> Tensor:
    '''
    Create a tensor of a specified size, applying a value to specified slices.
    
    Parameters
    ----------
    slcs : Slcs
        Tuples representing the slices.

    size : Size, optional
        The size of the tensor to create, defaults to (400, 400, 3).

    axes : AxesQ, optional
        The axes that the slices apply to, defaults to None.

    fmt : SliceFormat, optional
        The format of the slices, either 'coord' or 'slice', defaults to 'slice'.

    val : tuple, optional
        The value to apply to the slices, defaults to NaN.
        
    ttype : Numeric | type, optional
        The type of tensor to create, defaults to NaN.

    Returns
    -------
    Tensor
        The created tensor with the specified slices modified.

    Examples
    --------
    >>> slcswith((0, 100), (0, 100), size=(200, 200), val=1)
    # Returns a 200x200 tensor with the top-left 100x100 block set to 1

    Notes
    -----
    - meant to represent "sliced with"
    '''
    tfunc = torch.zeros
    if ttype == torch.nan:   tfunc = nans
    if ttype == torch.bool:  tfunc = torch.ones
    if ttype == torch.zeros: tfunc = nans

    return setslcs(tfunc(size), *slcs, axes=axes, fmt=fmt, val=val, inplace=True)     

# %% ../nbs/30_slcs.ipynb 26
def slcloc(
    *slcs: Slcs, size: Size = (400, 400, 3), axes: AxesQ = None,
    fmt: SliceFormat = SliceFormat.slice,
) -> BoolTensor:
    '''
    Convert slices to a boolean index tensor for a tensor of a given `size`.

    Parameters
    ----------
    slcs : Slcs
        Tuples representing the slices.

    size : Size, optional
        The size of the tensor to create, defaults to (400, 400, 3).

    axes : AxesQ, optional
        The axes that the slices apply to, defaults to None.
        
    fmt : SliceFormat, optional
        The format of the slices, either 'coord' or 'slice', defaults to 'slice'.

    Returns
    -------
    BoolTensor
        A boolean tensor indicating the locations of the slices.

    Examples
    --------
    >>> slcloc((0, 100), (0, 100), size=(200, 200))
    # Returns a 200x200 boolean tensor with True in the top-left 100x100 block
    '''
    tens = slcswith(*slcs, size=size, axes=axes, fmt=fmt, val=torch.nan, ttype=torch.zeros)     
    return tens.isnan() 

# %% ../nbs/30_slcs.ipynb 27
def slcval(
    *slcs: Slcs, size: Size = (400, 400, 3), axes: AxesQ = (0, 1), 
    fmt: SliceFormat = SliceFormat.slice, val: tuple = torch.nan,
) -> Tensor:
    '''
    Create a `tensor` of a specified `size`, applying a `value` only to specified `slices`.

    Parameters
    ----------
    slcs : Slcs
        Tuples representing the slices.

    size : Size, optional
        The size of the tensor to create, defaults to (400, 400, 3).

    axes : AxesQ, optional
        The axes that the slices apply to, defaults to (0, 1).

    fmt : SliceFormat, optional
        The format of the slices, either 'coord' or 'slice', defaults to 'slice'.
        
    val : tuple, optional
        The value to apply to the slices, defaults to NaN.

    Returns
    -------
    Tensor
        The created tensor with the specified value applied to the slices.

    Examples
    --------
    >>> slcval((0, 100), (0, 100), size=(200, 200), val=1)
    # Returns a 200x200 tensor with the top-left 100x100 block set to 1
    '''
    return slcswith(*slcs, size=size, axes=axes, fmt=fmt, val=val, ttype=torch.nan)     
