# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/22_util.ipynb.

# %% auto 0
__all__ = ['dimchars', 'size2str', 'calcgrid', 'grididx', 'pad4grid', 'nans', 'nanslike', 'resize', 'is2d', 'is3d', 'as2d',
           'as3d', 'as4d', 'last', 'batches', 'channels']

# %% ../nbs/22_util.ipynb 6
import math

# %% ../nbs/22_util.ipynb 8
from typing import overload

# %% ../nbs/22_util.ipynb 11
#| export

# %% ../nbs/22_util.ipynb 13
#| export


# %% ../nbs/22_util.ipynb 15
try: import torch, torch.nn as nn
except ImportError: torch, nn = None, None

# %% ../nbs/22_util.ipynb 17
#| export


# %% ../nbs/22_util.ipynb 19
from atyp import IntQ, Tensor, Grid, DeviceQ, ImgSizeQ, NanTensor, XYPos, Size
from chck import isnone

from pstr import charjoin, sunstr
from atup import fillnone

# %% ../nbs/22_util.ipynb 21
from .enum import Channels, DimType, DimName

# %% ../nbs/22_util.ipynb 23
def dimchars(dims: Size, dtype: DimType = DimType.ten):
    '''
    Returns a string representing the dimension characters for the given dimensions.

    Parameters
    ----------
    dims : tuple[int, ...]
        A tuple representing the dimensions of the tensor.
    dtype : DimType, optional
        The type of the tensor to provide context for dimension characters, defaults to DimType.ten.

    Returns
    -------
    str
        A string representing the dimension characters, or an empty string if no match is found.

    Examples
    --------
    >>> dimchars((3, 3, 3), DimType.ten)
    'ijk'

    >>> dimchars((1, 28, 28, 3), DimType.vid)
    'thwc'
    '''
    ndim = len(dims)    
    chars = DimName.get((dtype, ndim), '')    
    return chars.name if chars else ''

# %% ../nbs/22_util.ipynb 24
def size2str(
    size: ImgSizeQ, 
    use_cross: bool = False,
    dtype: DimType = DimType.img,    
) -> str:
    '''
    Converts a size tuple to a string representation, optionally including dimension characters.

    Parameters
    ----------
    size : ImgSizeQ
        The size tuple to be converted to a string.
    use_cross : bool, optional
        If True, uses a 'x' character to join dimensions, defaults to False.
    dtype : DimType, optional
        The type of the tensor for context in representation, defaults to DimType.img.

    Returns
    -------
    str
        The string representation of the size.
    '''
    if isnone(size): return ''
    dstr = dimchars(size, dtype)
    sstr = charjoin('x', *size) if use_cross else sunstr(*size)
    if dstr != '': return f'{dstr}_{sstr}'
    return sstr

# %% ../nbs/22_util.ipynb 26
def calcgrid(n: int) -> Grid:
    '''
    Find the closest rectangle layout that accommodates n elements.

    Parameters
    ----------
    n : int
        The number of elements to accommodate in the grid.

    Returns
    -------
    Grid
        A tuple representing the dimensions (rows, cols) of the grid.
    '''
    x = math.isqrt(n)
    while n % x != 0: x -= 1
    y = n // x
    return x, y

def grididx(pos: XYPos, grid: Grid) -> int:
    '''
    Calculate the linear index of an element in a `grid` given its `(row, col)` position (`pos`).

    Parameters
    ----------
    pos : XYPos
        A tuple representing the row and column position of the element in the grid.
    grid : Grid
        A tuple representing the dimensions of the grid (rows, columns).

    Returns
    -------
    int
        The linear index of the element in the grid.
    '''
    nrows, ncols = grid
    cur_r, cur_c = pos
    return cur_r * ncols + cur_c

# %% ../nbs/22_util.ipynb 27
@overload
def pad4grid(arr: list, rows: int, cols: int) -> list: ...
@overload
def pad4grid(arr: list, n: int) -> list: ...
def pad4grid(arr: list, *args) -> list:
    '''
    Pad the list of objects to the closest grid layout that accommodates a specified number of elements.

    Parameters
    ----------
    arr : list
        The list to be padded.
    args : int
        The dimensions of the grid `(rows, cols)` or the total number of elements `n`.

    Returns
    -------
    list
        The padded list.
    '''
    rows, cols = args[0], (1 if len(args) <= 1 else args[1])
    return list(fillnone(arr, rows * cols))

# %% ../nbs/22_util.ipynb 29
def nans(size: tuple) -> NanTensor:
    '''
    Create a tensor of `size` filled with `torch.nan`

    Parameters
    ----------
    size : tuple
        The size of the tensor to be created.

    Returns
    -------
    NanTensor
        A tensor of the specified size filled with NaN values.
    '''
    return torch.nan * torch.zeros(size)

def nanslike(t: Tensor) -> NanTensor: 
    '''
    Create a tensor of the same size as the given tensor, filled with NaN values.

    Parameters
    ----------
    t : Tensor
        The tensor to match the size of.

    Returns
    -------
    NanTensor
        A tensor of the same size as `t`, filled with NaN values.
    '''
    return nans(t.shape)

# %% ../nbs/22_util.ipynb 31
def resize(t: Tensor, resize: ImgSizeQ = None, output_channels: 'Channels' = Channels.THWC) -> Tensor:
    '''Resize a tensor and change its channel configuration if specified.

    Parameters
    ----------
    t : Tensor
        The tensor to resize.
    resize : ImgSizeQ, optional
        The new size to resize to, does nothing if None.
    output_channels : Channels, optional
        The channel configuration for the output tensor, defaults to Channels.THWC.

    Returns
    -------
    Tensor
        The resized tensor.

    See Also
    --------
    Channels.resize : Resize a tensor and change its channel configuration.
    '''
    return Channels.resize(t, resize, output_channels)

# %% ../nbs/22_util.ipynb 34
def is2d(t: Tensor) -> bool:
    '''Check if `t` is a 2D tensor.'''
    return t.ndim == 2

def is3d(t: Tensor) -> bool: 
    '''Check if `t` is a 3D tensor.'''
    return t.ndim == 3

# %% ../nbs/22_util.ipynb 36
def as2d(t: Tensor, device: DeviceQ = None) -> Tensor:
    '''Flatten a tensor to 2D.'''
    return torch.flatten(t, start_dim=1).to(device)
    
def as3d(t: Tensor, device: DeviceQ = None) -> Tensor:
    '''Flatten a tensor to 3D.'''
    return torch.flatten(t, start_dim=2).to(device)

def as4d(t: Tensor, height: int, width: int, channels: int = -1, device: DeviceQ = None) -> Tensor:
    '''Unflatten a tensor to 4D.'''
    shape = (height, width, )
    if is3d(t): t = torch.unflatten(t, 2, shape)
    else: t = torch.unflatten(t, 1, (channels, *shape, ))
    return t.to(device)

# %% ../nbs/22_util.ipynb 37
def last(t: Tensor, is_batched: bool = False) -> Tensor:
    '''Get the last value of the output `t`.'''
    if is2d(t) and not is_batched: return t[-1, :].unsqueeze(0)
    return t[:, -1, :].unsqueeze(1)

# %% ../nbs/22_util.ipynb 39
def batches(t: Tensor, batch_first: bool = True) -> IntQ: 
    '''Extract the batch size of tensor `t`.
    This will be either `None`, `x.size(0)` or `x.size(1)` depending on the 
    shape of `t` and the value of `batch_first`.

    Notes
    -----
    if `t` is a 2D tensor then `t` has shape:
        (L, H_in):    (seq_len, input_size)
    if `t` is a 3D tensor and `batch_first` is `True` then `t` has shape:
        (N, L, H_in): (batch_size, seq_len, input_size)
    otherwise `t` has shape:
        (L, N, H_in): (seq_len, batch_size, input_size)
    '''
    if is2d(t): return None
    return t.size(0 if batch_first else 1)

def channels(t: Tensor, batch_first: bool = True) -> IntQ:
    '''Extract the number of channels in tensor `t`.
    This will be either `x.size(0)` or `x.size(1)` depending on the 
    shape of `t` and the value of `batch_first`.
    
    Notes
    -----
    if `t` is a 2D tensor then `t` has shape:
        (L, H_in):    (seq_len, input_size)
    if `t` is a 3D tensor and `batch_first` is `True` then `t` has shape:
        (N, L, H_in): (batch_size, seq_len, input_size)
    otherwise `t` has shape:
        (L, N, H_in): (seq_len, batch_size, input_size)
    '''
    if is2d(t): return t.size(0)
    if is3d(t): return t.size(1 if batch_first else 0)
    return t.size(0)

# %% ../nbs/22_util.ipynb 41
#| export
