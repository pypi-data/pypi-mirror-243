# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/41_mask.ipynb.

# %% auto 0
__all__ = ['mask', 'bboxmask', 'reducemasks', 'applymasks', 'masktens']

# %% ../nbs/41_mask.ipynb 6
import functools

# %% ../nbs/41_mask.ipynb 8
#| export


# %% ../nbs/41_mask.ipynb 10
#| export


# %% ../nbs/41_mask.ipynb 12
#| export


# %% ../nbs/41_mask.ipynb 14
try: import torch
except: ...

# %% ../nbs/41_mask.ipynb 16
from atyp import (Tensor, BBox, Size, Color)
from chck import isnone

# %% ../nbs/41_mask.ipynb 18
from .atyp import MaskInfo
from .enum import SliceFormat
from .util import nans, resize
from .slcs import makeslcs, setslcs

# %% ../nbs/41_mask.ipynb 20
def mask(
    t: Tensor, *slcs: tuple,  
    axes: tuple = None, 
    fmt: SliceFormat = SliceFormat.slice, 
    val: tuple = torch.nan, 
    inplace: bool = False,
) -> Tensor:
    '''
    Apply a mask to a tensor at specified slices.

    Parameters
    ----------
    t : Tensor
        The tensor to apply the mask to.
    slcs : tuple
        Tuples representing the slices to apply the mask.
    axes : tuple, optional
        The axes corresponding to the slices, defaults to None.
    fmt : SliceFormat, optional
        Format of the slices, either 'coord' or 'slice', defaults to 'slice'.
    val : tuple, optional
        The value to use for the mask, defaults to NaN.
    inplace : bool, optional
        Whether to apply the mask in place, defaults to False.

    Returns
    -------
    Tensor
        The masked tensor.

    Examples
    --------
    >>> mask(torch.tensor([[1, 2], [3, 4]]), (0, 1), axes=(0,), val=0)
    tensor([[0, 0], [3, 4]])

    See Also
    --------
    `ptrc.slcs.setslcs` : Set values at specified slices.    
    '''
    return setslcs(t, *slcs, axes=axes, fmt=fmt, val=val, inplace=inplace)


# %% ../nbs/41_mask.ipynb 21
def bboxmask(bbox: BBox, size: Size = (400, 400, 3), color: Color = (0, 0, 0)) -> Tensor:
     '''
     Create a mask tensor with a bounding box applied.

     Parameters
     ----------
     bbox : BBox
          The bounding box coordinates.
     size : Size, optional
          The size of the tensor to create, defaults to (400, 400, 3).
     color : Color, optional
          The color to fill the bounding box, defaults to (0, 0, 0).

     Returns
     -------
     Tensor
          The tensor with a bounding box mask applied.

     Examples
     --------
     >>> bboxmask(((0, 0), (100, 100)))
     # Returns a tensor with the top-left 100x100 region colored.
     '''
     return mask(nans(size), *bbox, axes=(0, 1), fmt=SliceFormat.coord, val=color, inplace=False)

# %% ../nbs/41_mask.ipynb 22
def reducemasks(
    t: Tensor, 
    masks: list, 
    msize: tuple = (400, 400),
    axes: tuple = None, 
    fmt: SliceFormat = SliceFormat.coord,
    val: tuple = (0, 0, 0), 
    inplace: bool = False,
) -> Tensor:
    '''
    Apply multiple masks to a tensor and resize it.

    Parameters
    ----------
    t : Tensor
        The tensor to apply the masks to.
    masks : list
        A list of masks to apply.
    msize : tuple, optional
        The size to resize the tensor to after applying masks, defaults to (400, 400).
    axes : tuple, optional
        The axes corresponding to the masks, defaults to None.
    fmt : SliceFormat, optional
        Format of the slices in the masks, defaults to 'coord'.
    val : tuple, optional
        The value to use for the masks, defaults to (0, 0, 0).
    inplace : bool, optional
        Whether to apply the masks in place, defaults to False.

    Returns
    -------
    Tensor
        The masked and resized tensor.

    Examples
    --------
    >>> reducemasks(torch.tensor([[1, 2], [3, 4]]), [((0, 1),)], val=0)
    # Returns the tensor with a mask applied and resized.
    '''
    apply = functools.partial(mask, val=val, axes=axes, fmt=fmt, inplace=inplace)
    return functools.reduce(lambda v, m: apply(v, *m), masks, resize(t, msize))

# %% ../nbs/41_mask.ipynb 23
def applymasks(
    t: Tensor, 
    minfo: MaskInfo, 
    axes: tuple = (1, 2), 
    ndim: int = 4, 
    fmt: SliceFormat = SliceFormat.slice, 
    val: tuple = (0, 0, 0), 
    inplace: bool = True, 
    outsize: tuple = (32, 32),
) -> Tensor:
    '''
    Apply masks from MaskInfo to a tensor and resize it.

    Parameters
    ----------
    t : Tensor
        The tensor to apply the masks to.
    minfo : MaskInfo
        Mask information containing size, masks, and value.
    axes : tuple, optional
        The axes corresponding to the masks, defaults to (1, 2).
    ndim : int, optional
        The number of dimensions in the tensor, defaults to 4.
    fmt : SliceFormat, optional
        Format of the slices in the masks, defaults to 'slice'.
    val : tuple, optional
        The value to use for the masks, defaults to (0, 0, 0).
    inplace : bool, optional
        Whether to apply the masks in place, defaults to True.
    outsize : tuple, optional
        The size to resize the tensor to after applying masks, defaults to (32, 32).

    Returns
    -------
    Tensor
        The masked and resized tensor.

    Examples
    --------
    >>> applymasks(torch.rand(3, 400, 400), minfo)
    # Returns the tensor with masks applied and resized.
    '''
    if isnone(ndim): ndim = t.ndim
    msize, masks = minfo['size'], minfo['masks']
    # masks = masks2slc(maskinfo, axes=axes, ndim=ndim, fmt=fmt)
    masks = tuple(makeslcs(*slcs,  axes=axes, ndim=ndim, fmt=fmt) for slcs in masks.values())
    mtens = reducemasks(t, masks, msize=msize, axes=axes, fmt=fmt, inplace=inplace, val=val)
    return resize(mtens, outsize)
    

# %% ../nbs/41_mask.ipynb 24
def masktens(
    tens: list, 
    minfo: MaskInfo, 
    axes: tuple = (1, 2), 
    ndim: int = 4, 
    fmt: SliceFormat = SliceFormat.slice, 
    val: tuple = torch.nan, 
    inplace: bool = True,
    outsize: tuple = (32, 32),
) -> list:
    '''
    Apply masks from MaskInfo to a list of tensors and resize them.

    Parameters
    ----------
    tens : list
        A list of tensors to apply the masks to.
    minfo : MaskInfo
        Mask information containing size, masks, and value.
    axes : tuple, optional
        The axes corresponding to the masks, defaults to (1, 2).
    ndim : int, optional
        The number of dimensions in the tensors, defaults to 4.
    fmt : SliceFormat, optional
        Format of the slices in the masks, defaults to 'slice'.
    val : tuple, optional
        The value to use for the masks, defaults to NaN.
    inplace : bool, optional
        Whether to apply the masks in place, defaults to True.
    outsize : tuple, optional
        The size to resize the tensors to after applying masks, defaults to (32, 32).

    Returns
    -------
    list
        A list of masked and resized tensors.

    Examples
    --------
    >>> masktens([torch.rand(3, 400, 400)], minfo)
    # Returns a list of tensors with masks applied and resized.
    '''
    res = [applymasks(s, minfo, axes, ndim, fmt, val, inplace, outsize) for s in tens]
    return torch.stack(res)


    apply = functools.partial(applymasks, minfo=minfo, axes=axes, ndim=ndim, fmt=fmt, 
        val=val, inplace=inplace, outsize=outsize,)
    return [apply(s) for s in tens]
