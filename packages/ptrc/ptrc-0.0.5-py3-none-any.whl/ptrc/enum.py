# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/10_enum.ipynb.

# %% auto 0
__all__ = ['get_torch_module', 'missing', 'Channels', 'NonLinearity', 'InitMethod', 'RecurrentLayer', 'DimChars', 'DimType',
           'DimName', 'SliceFormat']

# %% ../nbs/10_enum.ipynb 6
from enum import Enum, StrEnum, auto
from functools import wraps

# %% ../nbs/10_enum.ipynb 8
from types import ModuleType

# %% ../nbs/10_enum.ipynb 11
#| export

# %% ../nbs/10_enum.ipynb 13
try: import numpy as np
except ImportError: ...

# %% ../nbs/10_enum.ipynb 15
try: import torch, torch.nn as nn
except ImportError: ...

# %% ../nbs/10_enum.ipynb 16
try: import torchvision.transforms.functional as F
except ImportError: ...

# %% ../nbs/10_enum.ipynb 18
#| export


# %% ../nbs/10_enum.ipynb 20
from atyp import Tensor, Layer, ImgSizeQ, BoolQ, Slcs
from chck import isnone, notnone, isslice

from nchr import U1, NIL

# %% ../nbs/10_enum.ipynb 22
#| export


# %% ../nbs/10_enum.ipynb 25
def get_torch_module(
    obj, 
    *args,
    __module: ModuleType = nn, 
    __enumkey: BoolQ = None,
    __enumval: BoolQ = None, 
    __suffix: str = NIL,
    **kwargs
) -> Layer:  
    '''
    Fetch a torch module based on an enumeration value or its name.

    Parameters
    ----------
    obj : Enum
        An enumeration instance or class.
    args : tuple
        Positional arguments to pass to the module constructor.
    __module : ModuleType, optional
        The torch module to fetch from, default is `torch.nn`.
    __enumkey : BoolQ, optional
        If True, use the enum's name for fetching, otherwise use the value.
    __enumval : BoolQ, optional
        If True, use the enum's value for fetching, otherwise use the name.
    __suffix : str, optional
        Suffix to append to the enum value or name.
    kwargs : dict
        Keyword arguments to pass to the module constructor.

    Returns
    -------
    Layer
        The instantiated torch module.
    '''
    # ensure that only one of __usekey and __useval is True
    usekey, useval = None, None
    if notnone(__enumkey): usekey = __enumkey
    if notnone(__enumval): useval = __enumval
    if isnone(usekey) and isnone(useval): usekey = True
    
    usekey = not useval if notnone(useval) else usekey
    useval = not usekey if notnone(usekey) else useval
    
    if issubclass(type(obj), Enum):
        val = getattr(obj, 'name' if usekey else 'value', obj.value)
        
    val = f'{val}{__suffix}'
    mod = getattr(__module, val)
    if args or kwargs: mod = mod(*args, **kwargs)
    return mod

# %% ../nbs/10_enum.ipynb 27
def missing(cls, val: str, default = None):
    '''
    Helper method to handle missing enum members.

    Parameters
    ----------
    cls : Enum
        The enumeration class.
    val : str
        The value to check for in the enum members.
    default : any, optional
        The default value to return if `val` is not found.

    Returns
    -------
    Enum member or default
        The matched enum member or the default value.
    '''
    val = val.lower()
    for member in cls:
        if member.value.lower() == val: 
            return member
    return default

# %% ../nbs/10_enum.ipynb 30
class Channels(StrEnum):
    '''
    Enumeration for different channel configurations in tensors, particularly for image data.

    Methods
    -------
    flip(t: Tensor) -> Tensor
        Flips the tensor between THWC and TCHW channel configurations.

    cidx(t: Tensor) -> int
        Returns the index of the channel dimension in the tensor.

    to(t: Tensor, c: 'Channels', cidx: int) -> Tensor
        Converts a tensor to the specified channel configuration.

    resize(t: Tensor, resize: ImgSizeQ, output_channels: 'Channels') -> Tensor
        Resizes the tensor and optionally changes its channel configuration.
    '''
    THWC = auto() # 0, 1, 2, 3
    TCHW = auto() # 0, 3, 1, 2
    
    @classmethod
    def flip(cls, t: Tensor) -> Tensor:
        '''Flips the tensor between THWC and TCHW channel configurations.'''
        return t.transpose(1, 3)
    
    @classmethod
    def cidx(cls, t: Tensor) -> int:
        '''Returns the index of the channel dimension'''
        idx = -1
        for i in range(len(t.shape)):
            if t.shape[i] != 3: continue
            idx = i
        
        idx = idx if idx >= 0 else np.argmin(t.shape)
        if (val := t.shape[idx]) not in {1, 3}: 
            raise ValueError(f'Expected eitehr 1 or 3 channels, got {val}')
        return idx
    
    @classmethod
    def _missing_(cls, val: str): return missing(cls, val, cls.THWC)
    
    @classmethod
    def safe(cls, c: 'Channels'):
        '''
        Safely retrieves the channel enumeration, defaulting to THWC if invalid.

        Parameters
        ----------
        c : Channels
            The channel configuration to validate.

        Returns
        -------
        Channels
            The validated channel configuration, defaults to THWC if input is invalid.
        '''
        try: return cls(c)
        except ValueError: return cls.THWC
        
    @classmethod
    def to(cls, t: Tensor, c: 'Channels' = 'THWC', cidx: int = None) -> Tensor:
        '''
        Converts a tensor to the specified channel configuration.

        Parameters
        ----------
        t : Tensor
            The input tensor to convert.
        c : Channels, optional
            The target channel configuration, defaults to THWC.
        cidx : int, optional
            The current channel index in the tensor, calculated if not provided.

        Returns
        -------
        Tensor
            The tensor converted to the specified channel configuration.
        '''
        c = cls.safe(c)
        if isnone(cidx): cidx = cls.cidx(t)
        if c == cls.THWC and cidx == 1: return cls.flip(t)
        if c == cls.THWC and cidx == 3: return t
        if c == cls.TCHW and cidx == 1: return t
        if c == cls.TCHW and cidx == 3: return cls.flip(t)
        return t
    
    @classmethod
    def resize(cls, t: Tensor, resize: ImgSizeQ = None, output_channels: 'Channels' = 'THWC') -> Tensor:
        '''
        Resizes a tensor and changes its channel configuration if needed.

        Parameters
        ----------
        t : Tensor
            The input tensor to resize.
        resize : ImgSizeQ, optional
            The target size for resizing, does nothing if None.
        output_channels : Channels, optional
            The channel configuration for the output tensor, defaults to THWC.

        Returns
        -------
        Tensor
            The resized tensor, potentially with a different channel configuration.
        '''
        if isnone(resize): return t
        t = Channels.to(t, Channels.TCHW)
        t = F.resize(t, resize)
        t = Channels.to(t, output_channels)
        return t

# %% ../nbs/10_enum.ipynb 32
class NonLinearity(StrEnum):
    '''
    Enumeration of non-linear activation functions and other related layers in PyTorch.

    Methods
    -------
    get(*args, **kwargs) -> Layer
        Retrieves the corresponding PyTorch layer or activation function.
    '''
    # weighted sum, nonlinearity
    ELU = auto()
    Hardshrink = auto()
    Hardsigmoid = auto()
    Hardtanh = auto()
    Hardswish = auto()
    LeakyReLU = auto()
    LogSigmoid = auto()
    MultiheadAttention = auto()
    PReLU = auto()
    SELU = auto()
    CELU = auto()
    GELU = auto()
    Sigmoid = auto()
    SiLU = auto()
    Mish = auto()
    Softplus = auto()
    Softshrink = auto()
    Tanh = auto()
    Tanhshrink = auto()
    Threshold = auto()
    GLU = auto()
    
    # other
    Softmin = auto()
    Softmax = auto()
    Softmax2d = auto()
    LogSoftmax = auto()
    AdaptiveLogSoftmaxWithLoss = auto()

    @classmethod
    def _missing_(cls, val: str): return missing(cls, val, cls.Tanh)
    
    def get(self, *args, **kwargs) -> Layer:
        '''Retrieves the corresponding PyTorch layer or activation function.'''
        return get_torch_module(self, *args, **kwargs)

# %% ../nbs/10_enum.ipynb 34
class InitMethod(StrEnum):
    '''
    Enumeration for different initialization methods for neural network layers in PyTorch.

    Methods
    -------
    get(*args, **kwargs) -> Layer
        Retrieves and applies the specified initialization method to a layer.
    '''
    constant = auto()
    dirac = auto()
    eye = auto()
    kaiming_normal = auto()
    normal = auto()
    orthogonal = auto()
    sparse = auto()
    uniform = auto()
    xavier_normal = auto()
    xavier_uniform = auto()
    zeros = auto()

    @classmethod
    def _missing_(cls, val: str): return missing(cls, val, cls.xavier_normal)

    def get(self, *args, **kwargs) -> Layer:
        '''Retrieves and applies the specified initialization method to a layer.'''
        suffix = kwargs.pop('__suffix', U1)
        return get_torch_module(self, *args, __module=nn.init, __enumval=True, __suffix=suffix, **kwargs)

# %% ../nbs/10_enum.ipynb 36
class RecurrentLayer(StrEnum):
    '''
    Enumeration for different types of recurrent layers in PyTorch.

    Methods
    -------
    get(*args, **kwargs) -> Layer
        Retrieves the corresponding recurrent layer from PyTorch.
    '''
    GRU = auto()
    RNN = auto()
    LSTM = auto()
    @classmethod
    def _missing_(cls, val: str): return missing(cls, val, cls.LSTM)
    
    @wraps(get_torch_module)
    def get(self, *args, **kwargs) -> Layer:
        '''Retrieves the corresponding recurrent layer from PyTorch.'''
        return get_torch_module(self, *args, **kwargs)

# %% ../nbs/10_enum.ipynb 39
class DimChars(StrEnum):
    '''
    Enumeration representing different dimensionality character labels for tensors.

    Members
    -------
    ijk : General 3D tensor.
    nchw : Tensor in NCHW format.
    nhwc : Tensor in NHWC format.
    xyz : General 3D spatial dimensions.
    thwc : Video in Time-Height-Width-Channel format.
    hw : 2D spatial dimensions (height and width).
    nhw : Batch of 2D spatial dimensions.

    Examples
    --------
    >>> DimChars.ijk
    DimChars.ijk

    >>> DimChars.nchw.name
    'nchw'
    '''
    
    ijk  = auto()
    '''General 3D tensor'''
    nchw = auto()
    '''Tensor in NCHW format'''
    nhwc = auto()
    '''Tensor in NHWC format'''
    xyz  = auto()
    '''General 3D spatial dimensions'''
    thwc = auto()
    '''Video in Time-Height-Width-Channel format'''
    hw   = auto()
    '''2D spatial dimensions (height and width)'''
    nhw  = auto()
    '''Batch of 2D spatial dimensions'''

# %% ../nbs/10_enum.ipynb 40
class DimType(StrEnum):
    '''
    Enumeration representing different types of data represented by tensors.

    Members
    -------
    ten : General tensor.
    arr : Array-like tensor.
    vid : Video data tensor.
    img : Image data tensor.

    Examples
    --------
    >>> DimType.ten
    DimType.ten

    >>> DimType.img.name
    'img'
    '''
    
    ten = auto()
    '''General tensor'''
    arr = auto()
    '''Array-like data'''
    vid = auto()
    '''Video data tensor'''
    img = auto()
    '''Image-data tensor'''

# %% ../nbs/10_enum.ipynb 41
class DimName:
    '''Enumeration representing different types of data represented by tensors.
    
    Notes
    -----
    - case `(DimType.ten, 3)` ==> `DimChars.ijk`
    - case `(DimType.arr, 3)` ==> `DimChars.xyz`
    - case `(DimType.vid, 4)` ==> `DimChars.thwc`
    - case `(DimType.vid, 3)` ==> `DimChars.hw`
    - case `(DimType.img, 2)` ==> `DimChars.hw`
    - case `(DimType.img, 3)` ==> `DimChars.nhw`
    '''
    @classmethod
    def get(cls, dtype: DimType, ndim: int) -> str:
        '''
        Gets the dimension name for the specified data type and number of dimensions.

        Notes
        -----
        - case `(DimType.ten, 3)` ==> `DimChars.ijk`
        - case `(DimType.arr, 3)` ==> `DimChars.xyz`
        - case `(DimType.vid, 4)` ==> `DimChars.thwc`
        - case `(DimType.vid, 3)` ==> `DimChars.hw`
        - case `(DimType.img, 2)` ==> `DimChars.hw`
        - case `(DimType.img, 3)` ==> `DimChars.nhw`
        '''
        match (dtype, ndim):
            case (DimType.ten, 3): return str(DimChars.ijk)
            case (DimType.arr, 3): return str(DimChars.xyz)
            case (DimType.vid, 4): return str(DimChars.thwc)
            case (DimType.vid, 3): return str(DimChars.hw)
            case (DimType.img, 2): return str(DimChars.hw)
            case (DimType.img, 3): return str(DimChars.nhw)
            case _: return ''

# %% ../nbs/10_enum.ipynb 44
class SliceFormat(StrEnum):
    '''
    Enumeration for representing different formats of slices used in tensor operations.

    This class provides methods to handle two common slice formats:
    - 'coord': where slices are represented as coordinates (e.g., (x0, y0, z0, ...), (x1, y1, z1, ...))
    - 'slice': where slices are represented as Python slice objects (e.g., (x0, x1), (y0, y1), (z0, z1), ...)

    Members
    -------
    coord : Auto-assigned Enum member
        Represents slices in coordinate format.
    slice : Auto-assigned Enum member
        Represents slices in Python slice object format.

    Methods
    -------
    flip(*slcs: Slcs) -> Slcs
        Flips the slice format from 'coord' to 'slice' or vice versa.

    safe(c: 'SliceFormat') -> 'SliceFormat'
        Safely returns a SliceFormat member, defaulting to 'slice' if input is invalid.

    guess(*slcs: Slcs) -> 'SliceFormat'
        Guesses the slice format based on the input slices.

    safeflip(*slcs: Slcs, fmt: 'SliceFormat') -> Slcs
        Safely flips the slice format, if necessary, to match the desired format.

    to(*slcs: Slcs, fmt: 'SliceFormat', cur: 'SliceFormat') -> Slcs
        Converts the given slices to the desired format, guessing the current format if not provided.

    Examples
    --------
    >>> SliceFormat.flip((0, 10), (0, 10))
    ((0, 0), (10, 10))

    >>> SliceFormat.safe('unknown_format')
    SliceFormat.slice

    >>> SliceFormat.to((0, 10), (0, 10), fmt=SliceFormat.coord)
    (0, 0), (10, 10)
    '''

    coord = auto()
    '''(x0, y0, z0, ...), (x1, y1, z1, ...), (x2, y2, z2, ...), ...'''
    slice = auto()
    '''(x0, x1, ), (y0, y1, ), (z0, z1, ), ...'''
    
    @classmethod
    def flip(cls, *slcs: Slcs) -> Slcs:
        '''
        Flips the format of the given slices between 'coord' and 'slice'.

        Parameters
        ----------
        slcs : Slcs
            The slices to flip. Can be in 'coord' or 'slice' format.

        Returns
        -------
        Slcs
            The slices flipped to the opposite format.

        Examples
        --------
        >>> SliceFormat.flip((0, 10), (0, 10))
        ((0, 0), (10, 10))
        '''
        return tuple(zip(*slcs))
    
    @classmethod
    def safe(cls, c: 'SliceFormat'):
        '''
        Safely returns a valid SliceFormat member.

        Parameters
        ----------
        c : SliceFormat
            The slice format to validate.

        Returns
        -------
        SliceFormat
            The validated slice format, defaults to 'slice' if input is invalid.

        Examples
        --------
        >>> SliceFormat.safe('unknown_format')
        SliceFormat.slice
        '''
        try: return cls(c)
        except ValueError: return cls.slice

    @classmethod
    def guess(cls, *slcs: Slcs) -> Slcs:
        '''
        Guesses the slice format based on the given slices.

        Parameters
        ----------
        slcs : Slcs
            The slices to evaluate.

        Returns
        -------
        SliceFormat
            The guessed slice format.

        Examples
        --------
        >>> SliceFormat.guess((0, 10), (0, 10))
        SliceFormat.slice
        '''
        if any(isslice(slc) for slc in slcs): return cls.slice
        if any([len(slc) > 3 for slc in slcs]): return cls.coord
        return cls.slice

    def safeflip(self, *slcs: Slcs, fmt: 'SliceFormat') -> Slcs:
        '''
        Safely flips the slice format to the specified format.

        Parameters
        ----------
        slcs : Slcs
            The slices to flip.
        fmt : SliceFormat
            The target format to flip to.

        Returns
        -------
        Slcs
            The slices in the specified format.

        Examples
        --------
        >>> SliceFormat.safeflip((0, 10), (0, 10), fmt=SliceFormat.coord)
        (0, 0), (10, 10)
        '''
        fmt = self.safe(fmt)
        if self == fmt: return slcs
        else: return self.flip(*slcs)

    @classmethod
    def to(cls, *slcs: Slcs, fmt: 'SliceFormat', cur: 'SliceFormat' = None) -> Slcs:
        '''
        Converts the given slices to the specified format.

        Parameters
        ----------
        slcs : Slcs
            The slices to convert.
        fmt : SliceFormat
            The target format for conversion.
        cur : SliceFormat, optional
            The current format of the slices, will be guessed if not provided.

        Returns
        -------
        Slcs
            The slices converted to the specified format.

        Examples
        --------
        >>> SliceFormat.to((0, 10), (0, 10), fmt=SliceFormat.coord)
        (0, 0), (10, 10)
        '''
        fmt = cls.safe(fmt)
        if isnone(cur): cur = cls.guess(*slcs)
        if cur == fmt: return slcs
        return cls.flip(*slcs)

# %% ../nbs/10_enum.ipynb 47
#| export
