# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/50_io.ipynb.

# %% auto 0
__all__ = ['videofps', 'subvideos', 'lsavi', 'vidinfo', 'info2df', 'subvidfile', 'vid2subs', 'load_avi', 'load_avisubs',
           'load_avis', 'save_avi', 'vid2subvids', 'vids2subvids', 'is_unnamed', 'read_xlsx']

# %% ../nbs/50_io.ipynb 6
import warnings, functools, itertools
from string import Template
from pathlib import Path
from enum import StrEnum, auto
from inspect import signature as getsig, getfullargspec as getspec
from dataclasses import dataclass, field

# %% ../nbs/50_io.ipynb 8
from types import TracebackType
from typing import Any, Dict, Tuple, Optional, Mapping, Literal, TypeAlias, Callable, TypedDict

# %% ../nbs/50_io.ipynb 10
try: from tqdm.auto import tqdm
except ImportError: tqdm = lambda x, desc='': x

# %% ../nbs/50_io.ipynb 12
try: import cv2
except ImportError: cv2 = None

# %% ../nbs/50_io.ipynb 14
try: import pandas as pd
except ImportError: ...

# %% ../nbs/50_io.ipynb 16
try: import torch
except ImportError: ...

# %% ../nbs/50_io.ipynb 17
try: import torchvision.io as tvio, torchvision.transforms.functional as F
except ImportError: ...

# %% ../nbs/50_io.ipynb 19
#| export


# %% ../nbs/50_io.ipynb 21
from atyp import FloatQ, PathLike, ImgSizeQ, Tensor, IntTensor, VidCap, CallQ, BoolQ, DataFrame
from chck import isnone, notnone, ispathlike, isvideo, iscall, isdict, istuple

from psrc import insert_exts, isavi, stemnums, aspath, rebase
from pstr import snek, prepart, endpart, sunstr, nilstr

from fpos import val1st
from putl import takekeys
from calr import callwith

# %% ../nbs/50_io.ipynb 23
from .atyp import SubVidInfo, VidInfo, VidsInfo, MaskInfo
from .enum import Channels, SliceFormat
from .util import grididx, pad4grid, calcgrid, size2str
from .vids import vidpxs, subpxs, getbbox
from .slcs import slcten
from .mask import masktens

# %% ../nbs/50_io.ipynb 26
def videofps(__default: float = 30.0, **kwargs) -> FloatQ:
    '''
    Extract the frames per second (fps) from video metadata.

    Parameters
    ----------
    __default : float, optional
        The default fps to return if not found in the metadata, default is 30.0.
    kwargs : dict
        Metadata dictionary where fps information might be stored.

    Returns
    -------
    FloatQ
        The extracted or default fps value.

    Examples
    --------
    >>> videofps(__default=24.0, meta={'fps': 30})
    30
    '''
    mkeys, fkeys = ('meta', 'video_meta', 'metadata',), ('fps', 'video_fps', )
    metadata = {**val1st(kwargs, mkeys , default={}), **kwargs}    
    videofps = int(val1st(metadata, fkeys, default=__default))
    return videofps


# %% ../nbs/50_io.ipynb 27
def subvideos(
    spec: VidCap | PathLike, __path: PathLike = None, 
    __func: CallQ = stemnums, __load: BoolQ = False,
    *args, **kwargs
) -> list[int]:
    '''
    Process video or path to extract subvideos information.

    Parameters
    ----------
    spec : VidCap | PathLike
        A video capture object or path to the video.
    __path : PathLike, optional
        An alternate path for the video.
    __func : CallQ, optional
        A function to process the video or path, defaults to stemnums.
    __load : BoolQ, optional
        If True, loads the video for processing, defaults to False.
    args, kwargs : 
        Additional arguments and keyword arguments for __func.

    Returns
    -------
    list[int]
        List of processed video information or indices.

    Examples
    --------
    >>> subvideos('/path/to/video.avi', __func=lambda x: [0, 1, 2])
    [0, 1, 2]
    '''
    src, vid = None, None
    if ispathlike(spec) or ispathlike(__path):
        src = Path(spec)
        if __load: vid = cv2.VideoCapture(str(src))
        
    elif hasattr(spec, 'path'):
        src = Path(vid.path)
        if not isvideo(spec) and __load:
            vid = cv2.VideoCapture(str(src))
    
    if iscall(__func):
        return callwith(__func, src, *args, __path=src, __video=vid, **kwargs)
    return __func(spec)

# %% ../nbs/50_io.ipynb 31
def lsavi(path: PathLike) -> list:
    '''
    List all AVI files in the specified directory.

    Parameters
    ----------
    path : PathLike
        The directory path to search for AVI files.

    Returns
    -------
    list
        A list of AVI file paths.

    Examples
    --------
    >>> lsavi('/path/to/directory')
    ['/path/to/directory/file1.avi', '/path/to/directory/file2.avi']
    '''
    return list(filter(isavi, path.ls()))

# %% ../nbs/50_io.ipynb 32
def vidinfo(path: Path, getsubvids: Callable = subvideos, *args, **kwargs) -> VidInfo:
    '''
    Extract video information and subvideo details from a given AVI file.

    Parameters
    ----------
    path : Path
        Path to the AVI file.
    getsubvids : Callable, optional
        A callable to extract subvideo information, defaults to subvideos.
    args : tuple
        Additional positional arguments passed to getsubvids.
    kwargs : dict
        Additional keyword arguments passed to getsubvids.

    Returns
    -------
    VidInfo
        Dictionary containing video and subvideo information.

    Examples
    --------
    >>> vidinfo(Path('/path/to/video.avi'))
    {'vidpxs': (1920, 1080), 'subpxs': (480, 270), 'values': [...], 'source': Path('/path/to/video.avi')}
    '''
    subs = getsubvids(path, *args, **kwargs)
    (rows, cols) = calcgrid(len(subs))
    padded = pad4grid(subs, rows, cols)
    mw, mh = vidpxs(path)
    sw, sh = subpxs(mw, mh, rows, cols)
    values = list(map(
        lambda key, pos : SubVidInfo(
            pos = pos, 
            bbox = getbbox(*pos, sw, sh), 
            subkey = key,
            subidx = grididx(pos, (rows, cols)), 
        ),
        padded, itertools.product(range(rows), range(cols))
    ))
    return VidInfo(vidpxs=(mw, mh), subpxs=(sw, sh), values=values, source=path)   

# %% ../nbs/50_io.ipynb 33
def info2df(infos: VidsInfo) -> DataFrame:
    '''
    Convert video information into a pandas DataFrame.

    Parameters
    ----------
    infos : VidsInfo
        Dictionary containing video information from multiple files.

    Returns
    -------
    DataFrame
        A pandas DataFrame containing the consolidated information.

    Examples
    --------
    >>> infos = {...} # dictionary of video information
    >>> df = info2df(infos)
    >>> df.head() # displays the first few rows of the dataframe
    '''
    data = []
    for path, info in infos.items():
        subinfo = info.get('values')
        base = dict(source=path, vidpxs=info['vidpxs'], subpxs=info['subpxs'])
        for sub in subinfo: data.append(dict(**base, **sub))
    df_info = pd.DataFrame(data)
    return df_info

# %% ../nbs/50_io.ipynb 34
def subvidfile(
    file: PathLike, name: str | SubVidInfo, kind: str = 'well', 
    dropat: str = '_wells_', root: Path = None
) -> Path:
    '''
    Construct a file path for a subvideo based on naming conventions.

    Parameters
    ----------
    file : PathLike
        The base file path.
    name : str | SubVidInfo
        Name or information of the subvideo.
    kind : str, optional
        A string to include in the file name, default is 'well'.
    dropat : str, optional
        A delimiter for processing the file name, default is '_wells_'.
    root : Path, optional
        The root directory for the new file path, defaults to None.

    Returns
    -------
    Path
        The constructed file path for the subvideo.

    Examples
    --------
    >>> subvidfile('/path/to/video.avi', 'subvid_1')
    Path('/path/to/video_subvid_1.avi')
    '''
    file = aspath(file)
    if isdict(name): name = name.get('label', name)

    prefix = prepart(file.stem, dropat)
    suffix = endpart(str(file), file.stem)
    
    stem = sunstr(prefix, kind, name)
    path = aspath(nilstr(stem, suffix))
    
    return rebase(file.with_name(path), root).resolve()

# %% ../nbs/50_io.ipynb 35
def vid2subs(video: PathLike, info: SubVidInfo) -> Tensor:
    '''
    Extract subvideos from a video file based on provided subvideo information.

    Parameters
    ----------
    video : PathLike
        The video file path.
    info : SubVidInfo
        Information about the subvideos to extract.

    Returns
    -------
    Tensor
        A tensor containing the extracted subvideos.

    Examples
    --------
    >>> vid2subs('/path/to/video.avi', info)
    # Returns a tensor with subvideos
    '''
    subvids = [slcten(video, *subinfo['bbox'], axes=(1, 2), fmt=SliceFormat.slice) for subinfo in info['values']]
    return torch.stack(subvids)

# %% ../nbs/50_io.ipynb 37
def load_avi(
    path: PathLike, resize: ImgSizeQ = None, channel_format: Channels = Channels.THWC, 
    ignore_exported: bool = False, **kwargs
):
    '''
    Load an AVI file, optionally resizing it and converting the channel format.

    Parameters
    ----------
    path : PathLike
        The path to the AVI file.
    resize : ImgSizeQ, optional
        The target size for resizing the video, defaults to None.
    channel_format : Channels, optional
        The channel format for the output video tensor, defaults to Channels.THWC.
    ignore_exported : bool, optional
        Whether to ignore previously exported files, defaults to False.
    kwargs : dict
        Additional keyword arguments for loading the video.

    Returns
    -------
    Tuple[Tensor, Tensor, dict]
        A tuple containing the video tensor, audio tensor, and metadata dictionary.

    Examples
    --------
    >>> video, audio, metadata = load_avi('/path/to/video.avi')
    '''
    warnings.filterwarnings('ignore', category=UserWarning, module='torchvision')
    if notnone(resize): channel_format = Channels.TCHW
    
    kwargs.setdefault('pts_unit', 'sec')
    readkeys = ('start_pts', 'end_pts', 'pts_unit')
    
    infile = insert_exts(path, 'torch', idx=-2)
    if infile.exists() and not ignore_exported: path = infile

    video, audio, mdata = tvio.read_video(str(path), output_format=channel_format, **takekeys(kwargs, readkeys))

    vsize = video.count_nonzero().item()
    asize = audio.count_nonzero().item()
    
    if notnone(resize) and vsize > 0: video = F.resize(video, resize)
    if notnone(resize) and asize > 0: audio = F.resize(audio, resize)
    
    return video, audio, mdata

# %% ../nbs/50_io.ipynb 38
def load_avisubs(path: PathLike, device: str = 'mps', ) -> (Tensor, dict):
    '''
    Load a video file and extract its subvideos, placing them onto a specified device.

    Parameters
    ----------
    path : PathLike
        The path to the video file.
    device : str, optional
        The device to which the video tensor should be transferred, default is 'mps'.

    Returns
    -------
    Tuple[Tensor, dict]
        A tuple containing the tensor of subvideos and the metadata dictionary.

    Examples
    --------
    >>> subvids, metadata = load_avisubs('/path/to/video.avi')
    '''
    info = vidinfo(path)
    video, _, mdict = load_avi(path)
    video = video.to(device)
    subvids = vid2subs(video, info)
    del video
    return subvids, mdict

# %% ../nbs/50_io.ipynb 39
def load_avis(
        paths: list,resize: ImgSizeQ = None, channel_format: Channels = Channels.THWC, 
        ignore_exported: bool = False, **kwargs
) -> (Tensor, IntTensor):
    '''
    Load multiple AVI files, applying specified transformations like resizing and channel format conversion.

    Parameters
    ----------
    paths : list
        A list of paths to AVI files.
    resize : ImgSizeQ, optional
        The target size for resizing the videos, defaults to None.
    channel_format : Channels, optional
        The channel format for the output video tensors, defaults to Channels.THWC.
    ignore_exported : bool, optional
        Whether to ignore previously exported files, defaults to False.
    kwargs : dict
        Additional keyword arguments for loading the videos.

    Returns
    -------
    Tuple[Tensor, IntTensor]
        A tuple containing a list of video tensors and their lengths.

    Examples
    --------
    >>> videos, lengths = load_avis(['/path/to/video1.avi', '/path/to/video2.avi'])
    '''
    load = functools.partial(
        load_avi, resize=resize, channel_format=channel_format, ignore_exported=ignore_exported, **kwargs
    )
    tens = [load_avi(path)[0] for path in paths]   
    lens = torch.tensor(load(map(lambda t: t.size(0), tens)))
    return tens, lens

# %% ../nbs/50_io.ipynb 41
def save_avi(
    path: PathLike, video: Tensor, exists_ok: bool = True, **kwargs
):
    '''
    Save a video tensor to an AVI file, with options for codec and other parameters.

    Parameters
    ----------
    path : PathLike
        The path where the video will be saved.
    video : Tensor
        The video tensor to save.
    exists_ok : bool, optional
        If False, raises an error if the file already exists, defaults to True.
    kwargs : dict
        Additional keyword arguments for video saving options.

    Examples
    --------
    >>> save_avi('/path/to/save/video.avi', video_tensor)
    '''
    outfile = insert_exts(path, 'torch', idx=-2)    
    fps = videofps(**kwargs)
    
    if outfile.is_file() and not exists_ok: 
        raise FileExistsError(outfile)
    
    writekeys = ('video_codec', 'options', 'audio_array', 'audio_fps', 'audio_codec', 'audio_options', )
    tvio.write_video(str(outfile), Channels.to(video, Channels.THWC), fps = fps, **takekeys(kwargs, writekeys))

# %% ../nbs/50_io.ipynb 42
def vid2subvids(
    path: PathLike, 
    maskinfo: MaskInfo,
    val: tuple = torch.nan, 
    axes: tuple = (1, 2), 
    ndim: int = 4, 
    fmt: SliceFormat = SliceFormat.slice, 
    inplace: bool = True,
    resize: tuple = (32, 32), 
    exists_ok: bool = True, 
    remake: bool = False, 
    savedir: PathLike = None, 
    device: str = 'mps',
    retsubs: bool = False,
    kind: str = 'well',
    dropat: str = '_wells_',
) -> VidInfo:
    '''
    Process a video file to extract, transform, and save its subvideos.

    Parameters
    ----------
    path : PathLike
        The path to the video file.
    maskinfo : MaskInfo
        Information on how to apply a mask to the video.
    val : tuple, optional
        Value to use for masking, defaults to torch.nan.
    axes : tuple, optional
        Axes along which to apply the mask, defaults to (1, 2).
    ndim : int, optional
        Number of dimensions of the output tensor, defaults to 4.
    fmt : SliceFormat, optional
        Format for slicing, defaults to SliceFormat.slice.
    inplace : bool, optional
        Whether to modify the tensor in place, defaults to True.
    resize : tuple, optional
        Target size for resizing the subvideos, defaults to (32, 32).
    exists_ok : bool, optional
        If False, raise error if the output file exists, defaults to True.
    remake : bool, optional
        If True, remake the subvideos even if they exist, defaults to False.
    savedir : PathLike, optional
        Directory to save the subvideos, defaults to None.
    device : str, optional
        Device to which tensors are moved, defaults to 'mps'.
    retsubs : bool, optional
        If True, return the subvideos, defaults to False.
    kind : str, optional
        Type of subvideo, used in naming, defaults to 'well'.
    dropat : str, optional
        Part of the filename to drop when creating subvideo names, defaults to '_wells_'.

    Returns
    -------
    dict or Tuple[dict, Tensor]
        The information about processed subvideos, and optionally the subvideo tensors.

    Examples
    --------
    >>> vid2subvids('/path/to/video.avi', maskinfo)
    # Returns information about the subvideos
    '''
    info = vidinfo(path)
    video, audio, mdict = load_avi(path)
    video = video.to(device)
    
    subs = vid2subs(video, info)
    subs = masktens(subs, maskinfo, axes=axes, ndim=ndim, fmt=fmt, val=val, inplace=inplace, outsize=resize)
    

    for subvid, subinfo in tqdm(list(zip(subs, info['values'])), desc='saving subvideos'):
        subpth = subvidfile(path, subinfo, kind, dropat, root=savedir)
        sstr = size2str(resize)
        
        if not remake and subpth.exists(): continue
        subpth = subpth.with_stem(sunstr(subpth.stem, sstr.removesuffix('_')))
        
        save_avi(subpth, subvid.to('cpu'), exists_ok=exists_ok, **mdict)
        subinfo.update(path=subpth, resize=resize, sstr=sstr)

    del video, audio
    info.update(metadata=mdict)
    if retsubs: return info, subs
    del subs
    return info

# %% ../nbs/50_io.ipynb 43
def vids2subvids(
    sources: list, 
    maskinfo: MaskInfo,
    val: tuple = torch.nan, 
    axes: tuple = (1, 2), 
    ndim: int = 4, 
    fmt: SliceFormat = SliceFormat.slice, 
    inplace: bool = True,
    resize: tuple = None, 
    exists_ok: bool = True, 
    remake: bool = False, 
    savedir: PathLike = None, 
    filename: str = 'subvids.csv', 
    device: str = 'mps',
    retsubs: bool = False,
    saveinfo: bool = True,
    kind: str = 'well',
    dropat: str = '_wells_',
) -> DataFrame:
    '''
    Process multiple video files to extract, transform, and save their subvideos, and consolidate the information.

    Parameters
    ----------
    sources : list
        A list of paths to video files.
    maskinfo : MaskInfo
        Information on how to apply a mask to the videos.
    val : tuple, optional
        Value to use for masking, defaults to torch.nan.
    axes : tuple, optional
        Axes along which to apply the mask, defaults to (1, 2).
    ndim : int, optional
        Number of dimensions of the output tensor, defaults to 4.
    fmt : SliceFormat, optional
        Format for slicing, defaults to SliceFormat.slice.
    inplace : bool, optional
        Whether to modify the tensor in place, defaults to True.
    resize : tuple, optional
        Target size for resizing the subvideos.
    exists_ok : bool, optional
        If False, raise error if the output file exists, defaults to True.
    remake : bool, optional
        If True, remake the subvideos even if they exist, defaults to False.
    savedir : PathLike, optional
        Directory to save the subvideos.
    filename : str, optional
        Name of the file to save the consolidated information, defaults to 'subvids.csv'.
    device : str, optional
        Device to which tensors are moved, defaults to 'mps'.
    retsubs : bool, optional
        If True, return the subvideos, defaults to False.
    saveinfo : bool, optional
        If True, save the consolidated information, defaults to True.
    kind : str, optional
        Type of subvideo, used in naming, defaults to 'well'.
    dropat : str, optional
        Part of the filename to drop when creating subvideo names, defaults to '_wells_'.

    Returns
    -------
    DataFrame
        A DataFrame containing consolidated information about all processed subvideos.

    Examples
    --------
    >>> df_subvids = vids2subvids(['/path/to/video1.avi', '/path/to/video2.avi'], maskinfo)
    # Returns a DataFrame with information about the subvideos
    '''
    srcinfo = dict()
    subvids = []
    savedir = aspath(savedir)
    
    for file in tqdm(sources, desc='Processing files...'):

        subout = vid2subvids(
            file, maskinfo, val, axes, ndim, fmt, inplace, resize, 
            exists_ok, remake, savedir, device, retsubs, kind, dropat
        )

        if istuple(subout):
            info = subout[0]
            subvids.extend(subout[1])
        else: 
            info = subout

        info.update(srcidx=sources.index(file))
        srcinfo[file] = info

    df_info = info2df(srcinfo)
    if saveinfo: df_info.to_csv(savedir / filename, index=False)
    if retsubs: return df_info, subvids
    del subvids
    return df_info

# %% ../nbs/50_io.ipynb 45
def is_unnamed(col: str) -> bool:
    '''
    Check if a column name is an unnamed/auto-generated name in a DataFrame.

    This function is useful when working with pandas DataFrames, as pandas often
    generates column names like 'Unnamed: 0' for unnamed columns when reading files.

    Parameters
    ----------
    col : str
        The column name to check.

    Returns
    -------
    bool
        True if the column name is an unnamed/auto-generated one, False otherwise.

    Examples
    --------
    >>> is_unnamed('Unnamed: 0')
    True

    >>> is_unnamed('my_column')
    False
    '''
    return col.strip().casefold().startswith('unnamed:')

# %% ../nbs/50_io.ipynb 46
def read_xlsx(path: str, file: str, readkws: dict = dict(), dropkws: dict = dict(axis=1, how='all')) -> DataFrame:
    '''
    Read an Excel file into a pandas DataFrame, applying post-processing like renaming and dropping columns.

    Parameters
    ----------
    path : str
        The directory path containing the Excel file.
    file : str
        The Excel file name.
    readkws : dict, optional
        Keyword arguments for pandas.read_excel function, defaults to an empty dict.
    dropkws : dict, optional
        Keyword arguments for DataFrame.dropna method, defaults to dropping all empty columns.

    Returns
    -------
    DataFrame
        A pandas DataFrame with the processed data from the Excel file.

    Examples
    --------
    >>> df = read_xlsx('/path/to/directory', 'data.xlsx')
    '''
    if isnone(readkws): readkws = dict()
    df = pd.read_excel(str(Path(path) / file), **readkws)
    df.columns = [c.strip() for c in df.columns]
    unnamed = [is_unnamed(c) for c in df.columns]
    df = df.loc[:, ~pd.Index(unnamed)]
    df.columns = [snek(c) for c in df.columns]
    if isinstance(dropkws, dict):
        df = df.dropna(**dropkws)
    return df
